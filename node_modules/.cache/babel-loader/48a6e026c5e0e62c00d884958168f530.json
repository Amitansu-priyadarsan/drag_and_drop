{"ast":null,"code":"import { invariant } from '@react-dnd/invariant';\nimport { ListenerType } from './interfaces.js';\nimport { OptionsReader } from './OptionsReader.js';\nimport { distance, inAngleRanges } from './utils/math.js';\nimport { getEventClientOffset, getNodeClientOffset } from './utils/offsets.js';\nimport { eventShouldEndDrag, eventShouldStartDrag, isTouchEvent } from './utils/predicates.js';\nimport { supportsPassive } from './utils/supportsPassive.js';\nconst eventNames = {\n  [ListenerType.mouse]: {\n    start: 'mousedown',\n    move: 'mousemove',\n    end: 'mouseup',\n    contextmenu: 'contextmenu'\n  },\n  [ListenerType.touch]: {\n    start: 'touchstart',\n    move: 'touchmove',\n    end: 'touchend'\n  },\n  [ListenerType.keyboard]: {\n    keydown: 'keydown'\n  }\n};\nexport class TouchBackendImpl {\n  /**\n  * Generate profiling statistics for the HTML5Backend.\n  */\n  profile() {\n    var ref;\n    return {\n      sourceNodes: this.sourceNodes.size,\n      sourcePreviewNodes: this.sourcePreviewNodes.size,\n      sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,\n      targetNodes: this.targetNodes.size,\n      dragOverTargetIds: ((ref = this.dragOverTargetIds) === null || ref === void 0 ? void 0 : ref.length) || 0\n    };\n  }\n  // public for test\n  get document() {\n    return this.options.document;\n  }\n  setup() {\n    const root = this.options.rootElement;\n    if (!root) {\n      return;\n    }\n    invariant(!TouchBackendImpl.isSetUp, 'Cannot have two Touch backends at the same time.');\n    TouchBackendImpl.isSetUp = true;\n    this.addEventListener(root, 'start', this.getTopMoveStartHandler());\n    this.addEventListener(root, 'start', this.handleTopMoveStartCapture, true);\n    this.addEventListener(root, 'move', this.handleTopMove);\n    this.addEventListener(root, 'move', this.handleTopMoveCapture, true);\n    this.addEventListener(root, 'end', this.handleTopMoveEndCapture, true);\n    if (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {\n      this.addEventListener(root, 'contextmenu', this.handleTopMoveEndCapture);\n    }\n    if (this.options.enableKeyboardEvents) {\n      this.addEventListener(root, 'keydown', this.handleCancelOnEscape, true);\n    }\n  }\n  teardown() {\n    const root = this.options.rootElement;\n    if (!root) {\n      return;\n    }\n    TouchBackendImpl.isSetUp = false;\n    this._mouseClientOffset = {};\n    this.removeEventListener(root, 'start', this.handleTopMoveStartCapture, true);\n    this.removeEventListener(root, 'start', this.handleTopMoveStart);\n    this.removeEventListener(root, 'move', this.handleTopMoveCapture, true);\n    this.removeEventListener(root, 'move', this.handleTopMove);\n    this.removeEventListener(root, 'end', this.handleTopMoveEndCapture, true);\n    if (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {\n      this.removeEventListener(root, 'contextmenu', this.handleTopMoveEndCapture);\n    }\n    if (this.options.enableKeyboardEvents) {\n      this.removeEventListener(root, 'keydown', this.handleCancelOnEscape, true);\n    }\n    this.uninstallSourceNodeRemovalObserver();\n  }\n  addEventListener(subject, event, handler) {\n    let capture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const options = supportsPassive ? {\n      capture,\n      passive: false\n    } : capture;\n    this.listenerTypes.forEach(function (listenerType) {\n      const evt = eventNames[listenerType][event];\n      if (evt) {\n        subject.addEventListener(evt, handler, options);\n      }\n    });\n  }\n  removeEventListener(subject, event, handler) {\n    let capture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const options = supportsPassive ? {\n      capture,\n      passive: false\n    } : capture;\n    this.listenerTypes.forEach(function (listenerType) {\n      const evt = eventNames[listenerType][event];\n      if (evt) {\n        subject.removeEventListener(evt, handler, options);\n      }\n    });\n  }\n  connectDragSource(sourceId, node) {\n    const handleMoveStart = this.handleMoveStart.bind(this, sourceId);\n    this.sourceNodes.set(sourceId, node);\n    this.addEventListener(node, 'start', handleMoveStart);\n    return () => {\n      this.sourceNodes.delete(sourceId);\n      this.removeEventListener(node, 'start', handleMoveStart);\n    };\n  }\n  connectDragPreview(sourceId, node, options) {\n    this.sourcePreviewNodeOptions.set(sourceId, options);\n    this.sourcePreviewNodes.set(sourceId, node);\n    return () => {\n      this.sourcePreviewNodes.delete(sourceId);\n      this.sourcePreviewNodeOptions.delete(sourceId);\n    };\n  }\n  connectDropTarget(targetId, node) {\n    const root = this.options.rootElement;\n    if (!this.document || !root) {\n      return () => {\n        /* noop */};\n    }\n    const handleMove = e => {\n      if (!this.document || !root || !this.monitor.isDragging()) {\n        return;\n      }\n      let coords;\n      /**\n      * Grab the coordinates for the current mouse/touch position\n      */\n      switch (e.type) {\n        case eventNames.mouse.move:\n          coords = {\n            x: e.clientX,\n            y: e.clientY\n          };\n          break;\n        case eventNames.touch.move:\n          var ref, ref1;\n          coords = {\n            x: ((ref = e.touches[0]) === null || ref === void 0 ? void 0 : ref.clientX) || 0,\n            y: ((ref1 = e.touches[0]) === null || ref1 === void 0 ? void 0 : ref1.clientY) || 0\n          };\n          break;\n      }\n      /**\n      * Use the coordinates to grab the element the drag ended on.\n      * If the element is the same as the target node (or any of it's children) then we have hit a drop target and can handle the move.\n      */\n      const droppedOn = coords != null ? this.document.elementFromPoint(coords.x, coords.y) : undefined;\n      const childMatch = droppedOn && node.contains(droppedOn);\n      if (droppedOn === node || childMatch) {\n        return this.handleMove(e, targetId);\n      }\n    };\n    /**\n    * Attaching the event listener to the body so that touchmove will work while dragging over multiple target elements.\n    */\n    this.addEventListener(this.document.body, 'move', handleMove);\n    this.targetNodes.set(targetId, node);\n    return () => {\n      if (this.document) {\n        this.targetNodes.delete(targetId);\n        this.removeEventListener(this.document.body, 'move', handleMove);\n      }\n    };\n  }\n  getTopMoveStartHandler() {\n    if (!this.options.delayTouchStart && !this.options.delayMouseStart) {\n      return this.handleTopMoveStart;\n    }\n    return this.handleTopMoveStartDelay;\n  }\n  installSourceNodeRemovalObserver(node) {\n    this.uninstallSourceNodeRemovalObserver();\n    this.draggedSourceNode = node;\n    this.draggedSourceNodeRemovalObserver = new MutationObserver(() => {\n      if (node && !node.parentElement) {\n        this.resurrectSourceNode();\n        this.uninstallSourceNodeRemovalObserver();\n      }\n    });\n    if (!node || !node.parentElement) {\n      return;\n    }\n    this.draggedSourceNodeRemovalObserver.observe(node.parentElement, {\n      childList: true\n    });\n  }\n  resurrectSourceNode() {\n    if (this.document && this.draggedSourceNode) {\n      this.draggedSourceNode.style.display = 'none';\n      this.draggedSourceNode.removeAttribute('data-reactid');\n      this.document.body.appendChild(this.draggedSourceNode);\n    }\n  }\n  uninstallSourceNodeRemovalObserver() {\n    if (this.draggedSourceNodeRemovalObserver) {\n      this.draggedSourceNodeRemovalObserver.disconnect();\n    }\n    this.draggedSourceNodeRemovalObserver = undefined;\n    this.draggedSourceNode = undefined;\n  }\n  constructor(manager, context, options) {\n    this.getSourceClientOffset = sourceId => {\n      const element = this.sourceNodes.get(sourceId);\n      return element && getNodeClientOffset(element);\n    };\n    this.handleTopMoveStartCapture = e => {\n      if (!eventShouldStartDrag(e)) {\n        return;\n      }\n      this.moveStartSourceIds = [];\n    };\n    this.handleMoveStart = sourceId => {\n      // Just because we received an event doesn't necessarily mean we need to collect drag sources.\n      // We only collect start collecting drag sources on touch and left mouse events.\n      if (Array.isArray(this.moveStartSourceIds)) {\n        this.moveStartSourceIds.unshift(sourceId);\n      }\n    };\n    this.handleTopMoveStart = e => {\n      if (!eventShouldStartDrag(e)) {\n        return;\n      }\n      // Don't prematurely preventDefault() here since it might:\n      // 1. Mess up scrolling\n      // 2. Mess up long tap (which brings up context menu)\n      // 3. If there's an anchor link as a child, tap won't be triggered on link\n      const clientOffset = getEventClientOffset(e);\n      if (clientOffset) {\n        if (isTouchEvent(e)) {\n          this.lastTargetTouchFallback = e.targetTouches[0];\n        }\n        this._mouseClientOffset = clientOffset;\n      }\n      this.waitingForDelay = false;\n    };\n    this.handleTopMoveStartDelay = e => {\n      if (!eventShouldStartDrag(e)) {\n        return;\n      }\n      const delay = e.type === eventNames.touch.start ? this.options.delayTouchStart : this.options.delayMouseStart;\n      this.timeout = setTimeout(this.handleTopMoveStart.bind(this, e), delay);\n      this.waitingForDelay = true;\n    };\n    this.handleTopMoveCapture = () => {\n      this.dragOverTargetIds = [];\n    };\n    this.handleMove = (_evt, targetId) => {\n      if (this.dragOverTargetIds) {\n        this.dragOverTargetIds.unshift(targetId);\n      }\n    };\n    this.handleTopMove = e1 => {\n      if (this.timeout) {\n        clearTimeout(this.timeout);\n      }\n      if (!this.document || this.waitingForDelay) {\n        return;\n      }\n      const {\n        moveStartSourceIds,\n        dragOverTargetIds\n      } = this;\n      const enableHoverOutsideTarget = this.options.enableHoverOutsideTarget;\n      const clientOffset = getEventClientOffset(e1, this.lastTargetTouchFallback);\n      if (!clientOffset) {\n        return;\n      }\n      // If the touch move started as a scroll, or is is between the scroll angles\n      if (this._isScrolling || !this.monitor.isDragging() && inAngleRanges(this._mouseClientOffset.x || 0, this._mouseClientOffset.y || 0, clientOffset.x, clientOffset.y, this.options.scrollAngleRanges)) {\n        this._isScrolling = true;\n        return;\n      }\n      // If we're not dragging and we've moved a little, that counts as a drag start\n      if (!this.monitor.isDragging() &&\n      // eslint-disable-next-line no-prototype-builtins\n      this._mouseClientOffset.hasOwnProperty('x') && moveStartSourceIds && distance(this._mouseClientOffset.x || 0, this._mouseClientOffset.y || 0, clientOffset.x, clientOffset.y) > (this.options.touchSlop ? this.options.touchSlop : 0)) {\n        this.moveStartSourceIds = undefined;\n        this.actions.beginDrag(moveStartSourceIds, {\n          clientOffset: this._mouseClientOffset,\n          getSourceClientOffset: this.getSourceClientOffset,\n          publishSource: false\n        });\n      }\n      if (!this.monitor.isDragging()) {\n        return;\n      }\n      const sourceNode = this.sourceNodes.get(this.monitor.getSourceId());\n      this.installSourceNodeRemovalObserver(sourceNode);\n      this.actions.publishDragSource();\n      if (e1.cancelable) e1.preventDefault();\n      // Get the node elements of the hovered DropTargets\n      const dragOverTargetNodes = (dragOverTargetIds || []).map(key => this.targetNodes.get(key)).filter(e => !!e);\n      // Get the a ordered list of nodes that are touched by\n      const elementsAtPoint = this.options.getDropTargetElementsAtPoint ? this.options.getDropTargetElementsAtPoint(clientOffset.x, clientOffset.y, dragOverTargetNodes) : this.document.elementsFromPoint(clientOffset.x, clientOffset.y);\n      // Extend list with parents that are not receiving elementsFromPoint events (size 0 elements and svg groups)\n      const elementsAtPointExtended = [];\n      for (const nodeId in elementsAtPoint) {\n        // eslint-disable-next-line no-prototype-builtins\n        if (!elementsAtPoint.hasOwnProperty(nodeId)) {\n          continue;\n        }\n        let currentNode = elementsAtPoint[nodeId];\n        if (currentNode != null) {\n          elementsAtPointExtended.push(currentNode);\n        }\n        while (currentNode) {\n          currentNode = currentNode.parentElement;\n          if (currentNode && elementsAtPointExtended.indexOf(currentNode) === -1) {\n            elementsAtPointExtended.push(currentNode);\n          }\n        }\n      }\n      const orderedDragOverTargetIds = elementsAtPointExtended // Filter off nodes that arent a hovered DropTargets nodes\n      .filter(node => dragOverTargetNodes.indexOf(node) > -1) // Map back the nodes elements to targetIds\n      .map(node => this._getDropTargetId(node)) // Filter off possible null rows\n      .filter(node => !!node).filter((id, index, ids) => ids.indexOf(id) === index);\n      // Invoke hover for drop targets when source node is still over and pointer is outside\n      if (enableHoverOutsideTarget) {\n        for (const targetId in this.targetNodes) {\n          const targetNode = this.targetNodes.get(targetId);\n          if (sourceNode && targetNode && targetNode.contains(sourceNode) && orderedDragOverTargetIds.indexOf(targetId) === -1) {\n            orderedDragOverTargetIds.unshift(targetId);\n            break;\n          }\n        }\n      }\n      // Reverse order because dnd-core reverse it before calling the DropTarget drop methods\n      orderedDragOverTargetIds.reverse();\n      this.actions.hover(orderedDragOverTargetIds, {\n        clientOffset: clientOffset\n      });\n    };\n    /**\n    *\n    * visible for testing\n    */\n    this._getDropTargetId = node => {\n      const keys = this.targetNodes.keys();\n      let next = keys.next();\n      while (next.done === false) {\n        const targetId = next.value;\n        if (node === this.targetNodes.get(targetId)) {\n          return targetId;\n        } else {\n          next = keys.next();\n        }\n      }\n      return undefined;\n    };\n    this.handleTopMoveEndCapture = e => {\n      this._isScrolling = false;\n      this.lastTargetTouchFallback = undefined;\n      if (!eventShouldEndDrag(e)) {\n        return;\n      }\n      if (!this.monitor.isDragging() || this.monitor.didDrop()) {\n        this.moveStartSourceIds = undefined;\n        return;\n      }\n      if (e.cancelable) e.preventDefault();\n      this._mouseClientOffset = {};\n      this.uninstallSourceNodeRemovalObserver();\n      this.actions.drop();\n      this.actions.endDrag();\n    };\n    this.handleCancelOnEscape = e => {\n      if (e.key === 'Escape' && this.monitor.isDragging()) {\n        this._mouseClientOffset = {};\n        this.uninstallSourceNodeRemovalObserver();\n        this.actions.endDrag();\n      }\n    };\n    this.options = new OptionsReader(options, context);\n    this.actions = manager.getActions();\n    this.monitor = manager.getMonitor();\n    this.sourceNodes = new Map();\n    this.sourcePreviewNodes = new Map();\n    this.sourcePreviewNodeOptions = new Map();\n    this.targetNodes = new Map();\n    this.listenerTypes = [];\n    this._mouseClientOffset = {};\n    this._isScrolling = false;\n    if (this.options.enableMouseEvents) {\n      this.listenerTypes.push(ListenerType.mouse);\n    }\n    if (this.options.enableTouchEvents) {\n      this.listenerTypes.push(ListenerType.touch);\n    }\n    if (this.options.enableKeyboardEvents) {\n      this.listenerTypes.push(ListenerType.keyboard);\n    }\n  }\n}","map":{"version":3,"sources":["../src/TouchBackendImpl.ts"],"names":["invariant","ListenerType","OptionsReader","distance","inAngleRanges","getEventClientOffset","getNodeClientOffset","eventShouldEndDrag","eventShouldStartDrag","isTouchEvent","supportsPassive","eventNames","mouse","start","move","end","contextmenu","touch","keyboard","keydown","TouchBackendImpl","manager","context","options","actions","getActions","monitor","getMonitor","sourceNodes","Map","sourcePreviewNodes","sourcePreviewNodeOptions","targetNodes","listenerTypes","_mouseClientOffset","_isScrolling","enableMouseEvents","push","enableTouchEvents","enableKeyboardEvents","profile","size","dragOverTargetIds","length","document","setup","root","rootElement","isSetUp","addEventListener","getTopMoveStartHandler","handleTopMoveStartCapture","handleTopMove","handleTopMoveCapture","handleTopMoveEndCapture","ignoreContextMenu","handleCancelOnEscape","teardown","removeEventListener","handleTopMoveStart","uninstallSourceNodeRemovalObserver","subject","event","handler","capture","passive","forEach","listenerType","evt","connectDragSource","sourceId","node","handleMoveStart","bind","set","delete","connectDragPreview","connectDropTarget","targetId","handleMove","e","isDragging","coords","type","x","clientX","y","clientY","touches","droppedOn","elementFromPoint","undefined","childMatch","contains","body","getSourceClientOffset","element","get","moveStartSourceIds","Array","isArray","unshift","delayTouchStart","delayMouseStart","handleTopMoveStartDelay","clientOffset","lastTargetTouchFallback","targetTouches","waitingForDelay","delay","timeout","setTimeout","_evt","clearTimeout","enableHoverOutsideTarget","scrollAngleRanges","hasOwnProperty","touchSlop","beginDrag","publishSource","sourceNode","getSourceId","installSourceNodeRemovalObserver","publishDragSource","cancelable","preventDefault","dragOverTargetNodes","map","key","filter","elementsAtPoint","getDropTargetElementsAtPoint","elementsFromPoint","elementsAtPointExtended","nodeId","currentNode","parentElement","indexOf","orderedDragOverTargetIds","_getDropTargetId","id","index","ids","targetNode","reverse","hover","keys","next","done","value","didDrop","drop","endDrag","draggedSourceNode","draggedSourceNodeRemovalObserver","MutationObserver","resurrectSourceNode","observe","childList","style","display","removeAttribute","appendChild","disconnect"],"mappings":"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","sourcesContent":["import { invariant } from '@react-dnd/invariant'\nimport type {\n\tBackend,\n\tDragDropActions,\n\tDragDropManager,\n\tDragDropMonitor,\n\tIdentifier,\n\tUnsubscribe,\n\tXYCoord,\n} from 'dnd-core'\n\nimport type {\n\tEventName,\n\tTouchBackendContext,\n\tTouchBackendOptions,\n} from './interfaces.js'\nimport { ListenerType } from './interfaces.js'\nimport { OptionsReader } from './OptionsReader.js'\nimport { distance, inAngleRanges } from './utils/math.js'\nimport { getEventClientOffset, getNodeClientOffset } from './utils/offsets.js'\nimport {\n\teventShouldEndDrag,\n\teventShouldStartDrag,\n\tisTouchEvent,\n} from './utils/predicates.js'\nimport { supportsPassive } from './utils/supportsPassive.js'\n\nconst eventNames: Record<ListenerType, EventName> = {\n\t[ListenerType.mouse]: {\n\t\tstart: 'mousedown',\n\t\tmove: 'mousemove',\n\t\tend: 'mouseup',\n\t\tcontextmenu: 'contextmenu',\n\t},\n\t[ListenerType.touch]: {\n\t\tstart: 'touchstart',\n\t\tmove: 'touchmove',\n\t\tend: 'touchend',\n\t},\n\t[ListenerType.keyboard]: {\n\t\tkeydown: 'keydown',\n\t},\n}\n\nexport class TouchBackendImpl implements Backend {\n\tprivate options: OptionsReader\n\n\t// React-DnD Dependencies\n\tprivate actions: DragDropActions\n\tprivate monitor: DragDropMonitor\n\n\t// Internal State\n\tprivate static isSetUp: boolean\n\tpublic sourceNodes: Map<Identifier, HTMLElement>\n\tpublic sourcePreviewNodes: Map<string, HTMLElement>\n\tpublic sourcePreviewNodeOptions: Map<string, any>\n\tpublic targetNodes: Map<string, HTMLElement>\n\tprivate _mouseClientOffset: Partial<XYCoord>\n\tprivate _isScrolling: boolean\n\tprivate listenerTypes: ListenerType[]\n\tprivate moveStartSourceIds: string[] | undefined\n\tprivate waitingForDelay: boolean | undefined\n\tprivate timeout: ReturnType<typeof setTimeout> | undefined\n\tprivate dragOverTargetIds: string[] | undefined\n\tprivate draggedSourceNode: HTMLElement | undefined\n\tprivate draggedSourceNodeRemovalObserver: MutationObserver | undefined\n\n\t// Patch for iOS 13, discussion over #1585\n\tprivate lastTargetTouchFallback: Touch | undefined\n\n\tpublic constructor(\n\t\tmanager: DragDropManager,\n\t\tcontext: TouchBackendContext,\n\t\toptions: Partial<TouchBackendOptions>,\n\t) {\n\t\tthis.options = new OptionsReader(options, context)\n\t\tthis.actions = manager.getActions()\n\t\tthis.monitor = manager.getMonitor()\n\n\t\tthis.sourceNodes = new Map()\n\t\tthis.sourcePreviewNodes = new Map()\n\t\tthis.sourcePreviewNodeOptions = new Map()\n\t\tthis.targetNodes = new Map()\n\t\tthis.listenerTypes = []\n\t\tthis._mouseClientOffset = {}\n\t\tthis._isScrolling = false\n\n\t\tif (this.options.enableMouseEvents) {\n\t\t\tthis.listenerTypes.push(ListenerType.mouse)\n\t\t}\n\n\t\tif (this.options.enableTouchEvents) {\n\t\t\tthis.listenerTypes.push(ListenerType.touch)\n\t\t}\n\n\t\tif (this.options.enableKeyboardEvents) {\n\t\t\tthis.listenerTypes.push(ListenerType.keyboard)\n\t\t}\n\t}\n\n\t/**\n\t * Generate profiling statistics for the HTML5Backend.\n\t */\n\tpublic profile(): Record<string, number> {\n\t\treturn {\n\t\t\tsourceNodes: this.sourceNodes.size,\n\t\t\tsourcePreviewNodes: this.sourcePreviewNodes.size,\n\t\t\tsourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,\n\t\t\ttargetNodes: this.targetNodes.size,\n\t\t\tdragOverTargetIds: this.dragOverTargetIds?.length || 0,\n\t\t}\n\t}\n\n\t// public for test\n\tpublic get document(): Document | undefined {\n\t\treturn this.options.document\n\t}\n\n\tpublic setup(): void {\n\t\tconst root = this.options.rootElement\n\t\tif (!root) {\n\t\t\treturn\n\t\t}\n\n\t\tinvariant(\n\t\t\t!TouchBackendImpl.isSetUp,\n\t\t\t'Cannot have two Touch backends at the same time.',\n\t\t)\n\t\tTouchBackendImpl.isSetUp = true\n\n\t\tthis.addEventListener(root, 'start', this.getTopMoveStartHandler() as any)\n\t\tthis.addEventListener(\n\t\t\troot,\n\t\t\t'start',\n\t\t\tthis.handleTopMoveStartCapture as any,\n\t\t\ttrue,\n\t\t)\n\t\tthis.addEventListener(root, 'move', this.handleTopMove as any)\n\t\tthis.addEventListener(root, 'move', this.handleTopMoveCapture, true)\n\t\tthis.addEventListener(\n\t\t\troot,\n\t\t\t'end',\n\t\t\tthis.handleTopMoveEndCapture as any,\n\t\t\ttrue,\n\t\t)\n\n\t\tif (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {\n\t\t\tthis.addEventListener(\n\t\t\t\troot,\n\t\t\t\t'contextmenu',\n\t\t\t\tthis.handleTopMoveEndCapture as any,\n\t\t\t)\n\t\t}\n\n\t\tif (this.options.enableKeyboardEvents) {\n\t\t\tthis.addEventListener(\n\t\t\t\troot,\n\t\t\t\t'keydown',\n\t\t\t\tthis.handleCancelOnEscape as any,\n\t\t\t\ttrue,\n\t\t\t)\n\t\t}\n\t}\n\n\tpublic teardown(): void {\n\t\tconst root = this.options.rootElement\n\t\tif (!root) {\n\t\t\treturn\n\t\t}\n\n\t\tTouchBackendImpl.isSetUp = false\n\t\tthis._mouseClientOffset = {}\n\n\t\tthis.removeEventListener(\n\t\t\troot,\n\t\t\t'start',\n\t\t\tthis.handleTopMoveStartCapture as any,\n\t\t\ttrue,\n\t\t)\n\t\tthis.removeEventListener(root, 'start', this.handleTopMoveStart as any)\n\t\tthis.removeEventListener(root, 'move', this.handleTopMoveCapture, true)\n\t\tthis.removeEventListener(root, 'move', this.handleTopMove as any)\n\t\tthis.removeEventListener(\n\t\t\troot,\n\t\t\t'end',\n\t\t\tthis.handleTopMoveEndCapture as any,\n\t\t\ttrue,\n\t\t)\n\n\t\tif (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {\n\t\t\tthis.removeEventListener(\n\t\t\t\troot,\n\t\t\t\t'contextmenu',\n\t\t\t\tthis.handleTopMoveEndCapture as any,\n\t\t\t)\n\t\t}\n\n\t\tif (this.options.enableKeyboardEvents) {\n\t\t\tthis.removeEventListener(\n\t\t\t\troot,\n\t\t\t\t'keydown',\n\t\t\t\tthis.handleCancelOnEscape as any,\n\t\t\t\ttrue,\n\t\t\t)\n\t\t}\n\n\t\tthis.uninstallSourceNodeRemovalObserver()\n\t}\n\n\tprivate addEventListener<K extends keyof EventName>(\n\t\tsubject: Node,\n\t\tevent: K,\n\t\thandler: (e: any) => void,\n\t\tcapture = false,\n\t) {\n\t\tconst options = supportsPassive ? { capture, passive: false } : capture\n\n\t\tthis.listenerTypes.forEach(function (listenerType) {\n\t\t\tconst evt = eventNames[listenerType][event]\n\n\t\t\tif (evt) {\n\t\t\t\tsubject.addEventListener(evt as any, handler as any, options)\n\t\t\t}\n\t\t})\n\t}\n\n\tprivate removeEventListener<K extends keyof EventName>(\n\t\tsubject: Node,\n\t\tevent: K,\n\t\thandler: (e: any) => void,\n\t\tcapture = false,\n\t) {\n\t\tconst options = supportsPassive ? { capture, passive: false } : capture\n\n\t\tthis.listenerTypes.forEach(function (listenerType) {\n\t\t\tconst evt = eventNames[listenerType][event]\n\n\t\t\tif (evt) {\n\t\t\t\tsubject.removeEventListener(evt as any, handler as any, options)\n\t\t\t}\n\t\t})\n\t}\n\n\tpublic connectDragSource(sourceId: string, node: HTMLElement): Unsubscribe {\n\t\tconst handleMoveStart = this.handleMoveStart.bind(this, sourceId)\n\t\tthis.sourceNodes.set(sourceId, node)\n\n\t\tthis.addEventListener(node, 'start', handleMoveStart)\n\n\t\treturn (): void => {\n\t\t\tthis.sourceNodes.delete(sourceId)\n\t\t\tthis.removeEventListener(node, 'start', handleMoveStart)\n\t\t}\n\t}\n\n\tpublic connectDragPreview(\n\t\tsourceId: string,\n\t\tnode: HTMLElement,\n\t\toptions: unknown,\n\t): Unsubscribe {\n\t\tthis.sourcePreviewNodeOptions.set(sourceId, options)\n\t\tthis.sourcePreviewNodes.set(sourceId, node)\n\n\t\treturn (): void => {\n\t\t\tthis.sourcePreviewNodes.delete(sourceId)\n\t\t\tthis.sourcePreviewNodeOptions.delete(sourceId)\n\t\t}\n\t}\n\n\tpublic connectDropTarget(targetId: string, node: HTMLElement): Unsubscribe {\n\t\tconst root = this.options.rootElement\n\t\tif (!this.document || !root) {\n\t\t\treturn (): void => {\n\t\t\t\t/* noop */\n\t\t\t}\n\t\t}\n\n\t\tconst handleMove = (e: MouseEvent | TouchEvent) => {\n\t\t\tif (!this.document || !root || !this.monitor.isDragging()) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tlet coords\n\n\t\t\t/**\n\t\t\t * Grab the coordinates for the current mouse/touch position\n\t\t\t */\n\t\t\tswitch (e.type) {\n\t\t\t\tcase eventNames.mouse.move:\n\t\t\t\t\tcoords = {\n\t\t\t\t\t\tx: (e as MouseEvent).clientX,\n\t\t\t\t\t\ty: (e as MouseEvent).clientY,\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\n\t\t\t\tcase eventNames.touch.move:\n\t\t\t\t\tcoords = {\n\t\t\t\t\t\tx: (e as TouchEvent).touches[0]?.clientX || 0,\n\t\t\t\t\t\ty: (e as TouchEvent).touches[0]?.clientY || 0,\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Use the coordinates to grab the element the drag ended on.\n\t\t\t * If the element is the same as the target node (or any of it's children) then we have hit a drop target and can handle the move.\n\t\t\t */\n\t\t\tconst droppedOn =\n\t\t\t\tcoords != null\n\t\t\t\t\t? this.document.elementFromPoint(coords.x, coords.y)\n\t\t\t\t\t: undefined\n\t\t\tconst childMatch = droppedOn && node.contains(droppedOn)\n\n\t\t\tif (droppedOn === node || childMatch) {\n\t\t\t\treturn this.handleMove(e, targetId)\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Attaching the event listener to the body so that touchmove will work while dragging over multiple target elements.\n\t\t */\n\t\tthis.addEventListener(this.document.body, 'move', handleMove as any)\n\t\tthis.targetNodes.set(targetId, node)\n\n\t\treturn (): void => {\n\t\t\tif (this.document) {\n\t\t\t\tthis.targetNodes.delete(targetId)\n\t\t\t\tthis.removeEventListener(this.document.body, 'move', handleMove as any)\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getSourceClientOffset = (sourceId: string): XYCoord | undefined => {\n\t\tconst element = this.sourceNodes.get(sourceId)\n\t\treturn element && getNodeClientOffset(element)\n\t}\n\n\tpublic handleTopMoveStartCapture = (e: Event): void => {\n\t\tif (!eventShouldStartDrag(e as MouseEvent)) {\n\t\t\treturn\n\t\t}\n\n\t\tthis.moveStartSourceIds = []\n\t}\n\n\tpublic handleMoveStart = (sourceId: string): void => {\n\t\t// Just because we received an event doesn't necessarily mean we need to collect drag sources.\n\t\t// We only collect start collecting drag sources on touch and left mouse events.\n\t\tif (Array.isArray(this.moveStartSourceIds)) {\n\t\t\tthis.moveStartSourceIds.unshift(sourceId)\n\t\t}\n\t}\n\n\tprivate getTopMoveStartHandler() {\n\t\tif (!this.options.delayTouchStart && !this.options.delayMouseStart) {\n\t\t\treturn this.handleTopMoveStart\n\t\t}\n\n\t\treturn this.handleTopMoveStartDelay\n\t}\n\n\tpublic handleTopMoveStart = (e: MouseEvent | TouchEvent): void => {\n\t\tif (!eventShouldStartDrag(e as MouseEvent)) {\n\t\t\treturn\n\t\t}\n\n\t\t// Don't prematurely preventDefault() here since it might:\n\t\t// 1. Mess up scrolling\n\t\t// 2. Mess up long tap (which brings up context menu)\n\t\t// 3. If there's an anchor link as a child, tap won't be triggered on link\n\n\t\tconst clientOffset = getEventClientOffset(e)\n\t\tif (clientOffset) {\n\t\t\tif (isTouchEvent(e)) {\n\t\t\t\tthis.lastTargetTouchFallback = e.targetTouches[0]\n\t\t\t}\n\t\t\tthis._mouseClientOffset = clientOffset\n\t\t}\n\t\tthis.waitingForDelay = false\n\t}\n\n\tpublic handleTopMoveStartDelay = (e: Event): void => {\n\t\tif (!eventShouldStartDrag(e as MouseEvent)) {\n\t\t\treturn\n\t\t}\n\n\t\tconst delay =\n\t\t\te.type === eventNames.touch.start\n\t\t\t\t? this.options.delayTouchStart\n\t\t\t\t: this.options.delayMouseStart\n\t\tthis.timeout = setTimeout(\n\t\t\tthis.handleTopMoveStart.bind(this, e as any),\n\t\t\tdelay,\n\t\t) as any as ReturnType<typeof setTimeout>\n\t\tthis.waitingForDelay = true\n\t}\n\n\tpublic handleTopMoveCapture = (): void => {\n\t\tthis.dragOverTargetIds = []\n\t}\n\n\tpublic handleMove = (\n\t\t_evt: MouseEvent | TouchEvent,\n\t\ttargetId: string,\n\t): void => {\n\t\tif (this.dragOverTargetIds) {\n\t\t\tthis.dragOverTargetIds.unshift(targetId)\n\t\t}\n\t}\n\n\tpublic handleTopMove = (e: TouchEvent | MouseEvent): void => {\n\t\tif (this.timeout) {\n\t\t\tclearTimeout(this.timeout)\n\t\t}\n\t\tif (!this.document || this.waitingForDelay) {\n\t\t\treturn\n\t\t}\n\t\tconst { moveStartSourceIds, dragOverTargetIds } = this\n\t\tconst enableHoverOutsideTarget = this.options.enableHoverOutsideTarget\n\n\t\tconst clientOffset = getEventClientOffset(e, this.lastTargetTouchFallback)\n\n\t\tif (!clientOffset) {\n\t\t\treturn\n\t\t}\n\n\t\t// If the touch move started as a scroll, or is is between the scroll angles\n\t\tif (\n\t\t\tthis._isScrolling ||\n\t\t\t(!this.monitor.isDragging() &&\n\t\t\t\tinAngleRanges(\n\t\t\t\t\tthis._mouseClientOffset.x || 0,\n\t\t\t\t\tthis._mouseClientOffset.y || 0,\n\t\t\t\t\tclientOffset.x,\n\t\t\t\t\tclientOffset.y,\n\t\t\t\t\tthis.options.scrollAngleRanges,\n\t\t\t\t))\n\t\t) {\n\t\t\tthis._isScrolling = true\n\t\t\treturn\n\t\t}\n\n\t\t// If we're not dragging and we've moved a little, that counts as a drag start\n\t\tif (\n\t\t\t!this.monitor.isDragging() &&\n\t\t\t// eslint-disable-next-line no-prototype-builtins\n\t\t\tthis._mouseClientOffset.hasOwnProperty('x') &&\n\t\t\tmoveStartSourceIds &&\n\t\t\tdistance(\n\t\t\t\tthis._mouseClientOffset.x || 0,\n\t\t\t\tthis._mouseClientOffset.y || 0,\n\t\t\t\tclientOffset.x,\n\t\t\t\tclientOffset.y,\n\t\t\t) > (this.options.touchSlop ? this.options.touchSlop : 0)\n\t\t) {\n\t\t\tthis.moveStartSourceIds = undefined\n\n\t\t\tthis.actions.beginDrag(moveStartSourceIds, {\n\t\t\t\tclientOffset: this._mouseClientOffset,\n\t\t\t\tgetSourceClientOffset: this.getSourceClientOffset,\n\t\t\t\tpublishSource: false,\n\t\t\t})\n\t\t}\n\n\t\tif (!this.monitor.isDragging()) {\n\t\t\treturn\n\t\t}\n\n\t\tconst sourceNode = this.sourceNodes.get(\n\t\t\tthis.monitor.getSourceId() as string,\n\t\t)\n\t\tthis.installSourceNodeRemovalObserver(sourceNode)\n\t\tthis.actions.publishDragSource()\n\n\t\tif (e.cancelable) e.preventDefault()\n\n\t\t// Get the node elements of the hovered DropTargets\n\t\tconst dragOverTargetNodes: HTMLElement[] = (dragOverTargetIds || [])\n\t\t\t.map((key) => this.targetNodes.get(key))\n\t\t\t.filter((e) => !!e) as HTMLElement[]\n\n\t\t// Get the a ordered list of nodes that are touched by\n\t\tconst elementsAtPoint = this.options.getDropTargetElementsAtPoint\n\t\t\t? this.options.getDropTargetElementsAtPoint(\n\t\t\t\t\tclientOffset.x,\n\t\t\t\t\tclientOffset.y,\n\t\t\t\t\tdragOverTargetNodes,\n\t\t\t  )\n\t\t\t: this.document.elementsFromPoint(clientOffset.x, clientOffset.y)\n\t\t// Extend list with parents that are not receiving elementsFromPoint events (size 0 elements and svg groups)\n\t\tconst elementsAtPointExtended: Element[] = []\n\t\tfor (const nodeId in elementsAtPoint) {\n\t\t\t// eslint-disable-next-line no-prototype-builtins\n\t\t\tif (!elementsAtPoint.hasOwnProperty(nodeId)) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlet currentNode: Element | undefined | null = elementsAtPoint[nodeId]\n\t\t\tif (currentNode != null) {\n\t\t\t\telementsAtPointExtended.push(currentNode)\n\t\t\t}\n\t\t\twhile (currentNode) {\n\t\t\t\tcurrentNode = currentNode.parentElement\n\t\t\t\tif (\n\t\t\t\t\tcurrentNode &&\n\t\t\t\t\telementsAtPointExtended.indexOf(currentNode) === -1\n\t\t\t\t) {\n\t\t\t\t\telementsAtPointExtended.push(currentNode)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst orderedDragOverTargetIds: string[] = elementsAtPointExtended\n\t\t\t// Filter off nodes that arent a hovered DropTargets nodes\n\t\t\t.filter((node) => dragOverTargetNodes.indexOf(node as HTMLElement) > -1)\n\t\t\t// Map back the nodes elements to targetIds\n\t\t\t.map((node) => this._getDropTargetId(node))\n\t\t\t// Filter off possible null rows\n\t\t\t.filter((node) => !!node)\n\t\t\t.filter((id, index, ids) => ids.indexOf(id) === index) as string[]\n\n\t\t// Invoke hover for drop targets when source node is still over and pointer is outside\n\t\tif (enableHoverOutsideTarget) {\n\t\t\tfor (const targetId in this.targetNodes) {\n\t\t\t\tconst targetNode = this.targetNodes.get(targetId)\n\t\t\t\tif (\n\t\t\t\t\tsourceNode &&\n\t\t\t\t\ttargetNode &&\n\t\t\t\t\ttargetNode.contains(sourceNode) &&\n\t\t\t\t\torderedDragOverTargetIds.indexOf(targetId) === -1\n\t\t\t\t) {\n\t\t\t\t\torderedDragOverTargetIds.unshift(targetId)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Reverse order because dnd-core reverse it before calling the DropTarget drop methods\n\t\torderedDragOverTargetIds.reverse()\n\n\t\tthis.actions.hover(orderedDragOverTargetIds, {\n\t\t\tclientOffset: clientOffset,\n\t\t})\n\t}\n\n\t/**\n\t *\n\t * visible for testing\n\t */\n\tpublic _getDropTargetId = (node: Element): Identifier | undefined => {\n\t\tconst keys = this.targetNodes.keys()\n\t\tlet next = keys.next()\n\t\twhile (next.done === false) {\n\t\t\tconst targetId = next.value\n\t\t\tif (node === this.targetNodes.get(targetId)) {\n\t\t\t\treturn targetId\n\t\t\t} else {\n\t\t\t\tnext = keys.next()\n\t\t\t}\n\t\t}\n\t\treturn undefined\n\t}\n\n\tpublic handleTopMoveEndCapture = (e: Event): void => {\n\t\tthis._isScrolling = false\n\t\tthis.lastTargetTouchFallback = undefined\n\n\t\tif (!eventShouldEndDrag(e as MouseEvent)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (!this.monitor.isDragging() || this.monitor.didDrop()) {\n\t\t\tthis.moveStartSourceIds = undefined\n\t\t\treturn\n\t\t}\n\n\t\tif (e.cancelable) e.preventDefault()\n\n\t\tthis._mouseClientOffset = {}\n\n\t\tthis.uninstallSourceNodeRemovalObserver()\n\t\tthis.actions.drop()\n\t\tthis.actions.endDrag()\n\t}\n\n\tpublic handleCancelOnEscape = (e: KeyboardEvent): void => {\n\t\tif (e.key === 'Escape' && this.monitor.isDragging()) {\n\t\t\tthis._mouseClientOffset = {}\n\n\t\t\tthis.uninstallSourceNodeRemovalObserver()\n\t\t\tthis.actions.endDrag()\n\t\t}\n\t}\n\n\tprivate installSourceNodeRemovalObserver(node: HTMLElement | undefined) {\n\t\tthis.uninstallSourceNodeRemovalObserver()\n\n\t\tthis.draggedSourceNode = node\n\t\tthis.draggedSourceNodeRemovalObserver = new MutationObserver(() => {\n\t\t\tif (node && !node.parentElement) {\n\t\t\t\tthis.resurrectSourceNode()\n\t\t\t\tthis.uninstallSourceNodeRemovalObserver()\n\t\t\t}\n\t\t})\n\n\t\tif (!node || !node.parentElement) {\n\t\t\treturn\n\t\t}\n\n\t\tthis.draggedSourceNodeRemovalObserver.observe(node.parentElement, {\n\t\t\tchildList: true,\n\t\t})\n\t}\n\n\tprivate resurrectSourceNode() {\n\t\tif (this.document && this.draggedSourceNode) {\n\t\t\tthis.draggedSourceNode.style.display = 'none'\n\t\t\tthis.draggedSourceNode.removeAttribute('data-reactid')\n\t\t\tthis.document.body.appendChild(this.draggedSourceNode)\n\t\t}\n\t}\n\n\tprivate uninstallSourceNodeRemovalObserver() {\n\t\tif (this.draggedSourceNodeRemovalObserver) {\n\t\t\tthis.draggedSourceNodeRemovalObserver.disconnect()\n\t\t}\n\n\t\tthis.draggedSourceNodeRemovalObserver = undefined\n\t\tthis.draggedSourceNode = undefined\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}
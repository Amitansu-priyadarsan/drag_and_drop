{"ast":null,"code":"import React, { createContext, useImperativeHandle, useState, useContext, useEffect, useRef, forwardRef } from 'react';\nimport { HTML5Backend, getEmptyImage } from 'react-dnd-html5-backend';\nimport { PointerTransition, TouchTransition } from 'dnd-multi-backend';\nexport { MultiBackend } from 'dnd-multi-backend';\nimport { TouchBackend } from 'react-dnd-touch-backend';\nimport { useDrag, useDrop, useDragLayer, useDragDropManager } from 'react-dnd';\nexport { DndProvider } from 'react-dnd';\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nfunction __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\nvar compareItems = function (a, b) {\n  if (a.text > b.text) {\n    return 1;\n  } else if (a.text < b.text) {\n    return -1;\n  }\n  return 0;\n};\nvar getTreeItem = function (tree, id) {\n  return tree.find(function (n) {\n    return n.id === id;\n  });\n};\nvar isAncestor = function (tree, sourceId, targetId) {\n  if (targetId === 0) {\n    return false;\n  }\n  var targetNode = tree.find(function (node) {\n    return node.id === targetId;\n  });\n  if (targetNode === undefined) {\n    return false;\n  }\n  if (targetNode.parent === sourceId) {\n    return true;\n  }\n  return isAncestor(tree, sourceId, targetNode.parent);\n};\nvar isDroppable = function (dragSourceId, dropTargetId, treeContext) {\n  var tree = treeContext.tree,\n    rootId = treeContext.rootId,\n    canDrop = treeContext.canDrop;\n  if (dragSourceId === undefined) {\n    if (dropTargetId === rootId) {\n      return true;\n    }\n    var dropTargetNode = tree.find(function (node) {\n      return node.id === dropTargetId;\n    });\n    if (dropTargetNode && dropTargetNode.droppable) {\n      return true;\n    }\n    return false;\n  } else {\n    if (canDrop) {\n      var result = canDrop(dragSourceId, dropTargetId);\n      if (result !== undefined) {\n        return result;\n      }\n    }\n    if (dragSourceId === dropTargetId) {\n      return false;\n    }\n    var dragSourceNode = tree.find(function (node) {\n      return node.id === dragSourceId;\n    });\n    if (dragSourceNode === undefined || dragSourceNode.parent === dropTargetId) {\n      return false;\n    }\n    if (dropTargetId === rootId) {\n      return true;\n    }\n    var dropTargetNode = tree.find(function (node) {\n      return node.id === dropTargetId;\n    });\n    if (dropTargetNode === undefined || !dropTargetNode.droppable) {\n      return false;\n    }\n    return !isAncestor(tree, dragSourceId, dropTargetId);\n  }\n};\nvar mutateTree = function (tree, dragSourceId, dropTargetId) {\n  return tree.map(function (node) {\n    if (node.id === dragSourceId) {\n      return __assign(__assign({}, node), {\n        parent: dropTargetId\n      });\n    }\n    return node;\n  });\n};\nvar getSrcIndex = function (tree, dragSourceId) {\n  return tree.findIndex(function (node) {\n    return node.id === dragSourceId;\n  });\n};\nvar getDestIndex = function (tree, dropTargetId, index) {\n  if (index === 0) {\n    return 0;\n  }\n  var siblings = tree.filter(function (node) {\n    return node.parent === dropTargetId;\n  });\n  if (siblings[index]) {\n    return tree.findIndex(function (node) {\n      return node.id === siblings[index].id;\n    });\n  }\n  return tree.findIndex(function (node) {\n    return node.id === siblings[index - 1].id;\n  }) + 1;\n};\nvar getModifiedIndex = function (tree, dragSourceId, dropTargetId, index) {\n  var srcIndex = getSrcIndex(tree, dragSourceId);\n  var destIndex = getDestIndex(tree, dropTargetId, index);\n  destIndex = destIndex > srcIndex ? destIndex - 1 : destIndex;\n  return [srcIndex, destIndex];\n};\nvar arrayMoveMutable = function (array, fromIndex, toIndex) {\n  var startIndex = fromIndex < 0 ? array.length + fromIndex : fromIndex;\n  if (startIndex >= 0 && startIndex < array.length) {\n    var endIndex = toIndex < 0 ? array.length + toIndex : toIndex;\n    var item = array.splice(fromIndex, 1)[0];\n    array.splice(endIndex, 0, item);\n  }\n};\nvar mutateTreeWithIndex = function (tree, dragSourceId, dropTargetId, index) {\n  var _a = getModifiedIndex(tree, dragSourceId, dropTargetId, index),\n    srcIndex = _a[0],\n    destIndex = _a[1];\n  var newTree = __spreadArray([], tree, true);\n  arrayMoveMutable(newTree, srcIndex, destIndex);\n  return newTree.map(function (node) {\n    if (node.id === dragSourceId) {\n      return __assign(__assign({}, node), {\n        parent: dropTargetId\n      });\n    }\n    return node;\n  });\n};\nvar compareYCoord = function (el, pointerY) {\n  var bbox = el.getBoundingClientRect();\n  var centerY = bbox.top + bbox.height / 2;\n  return pointerY > centerY ? \"down\" : \"up\";\n};\nvar getInnerIndex = function (listItems, monitor) {\n  var pos = \"\";\n  var index = 0;\n  listItems.forEach(function (el, key) {\n    var _a;\n    var flag = compareYCoord(el, ((_a = monitor.getClientOffset()) === null || _a === void 0 ? void 0 : _a.y) || 0);\n    if (pos === \"\") {\n      pos = flag;\n    } else if (pos !== flag) {\n      pos = flag;\n      index = key;\n    }\n    if (key === listItems.length - 1 && flag === \"down\") {\n      index = key + 1;\n    }\n  });\n  return index;\n};\nvar getOuterIndex = function (node, nodeEl, monitor) {\n  var parentList = nodeEl.closest('[role=\"list\"]');\n  var parentListItems = parentList === null || parentList === void 0 ? void 0 : parentList.querySelectorAll(':scope > [role=\"listitem\"]');\n  if (!parentListItems) {\n    return null;\n  }\n  return getInnerIndex(parentListItems, monitor);\n};\nvar getHoverPosition = function (el, pointerY, context) {\n  var bbox = el.getBoundingClientRect();\n  var offsetY = context.dropTargetOffset;\n  var upSideY = bbox.top + offsetY;\n  var lowerSideY = bbox.bottom - offsetY;\n  if (pointerY > lowerSideY) {\n    return \"lower\";\n  } else if (pointerY < upSideY) {\n    return \"upper\";\n  }\n  return \"middle\";\n};\nvar getDropTarget = function (node, nodeEl, monitor, context) {\n  var _a;\n  if (!nodeEl) {\n    return null;\n  }\n  if (node === null) {\n    var listItems = nodeEl.querySelectorAll(':scope > [role=\"listitem\"]');\n    return {\n      id: context.rootId,\n      index: getInnerIndex(listItems, monitor)\n    };\n  }\n  var dragSource = monitor.getItem();\n  var list = nodeEl.querySelector('[role=\"list\"]');\n  var hoverPosition = getHoverPosition(nodeEl, ((_a = monitor.getClientOffset()) === null || _a === void 0 ? void 0 : _a.y) || 0, context);\n  if (!list) {\n    if (hoverPosition === \"middle\") {\n      return {\n        id: node.id,\n        index: 0\n      };\n    }\n    if (isDroppable(dragSource.id, node.parent, context)) {\n      var outerIndex = getOuterIndex(node, nodeEl, monitor);\n      if (outerIndex === null) {\n        return null;\n      }\n      return {\n        id: node.parent,\n        index: outerIndex\n      };\n    }\n    return null;\n  } else {\n    if (hoverPosition === \"upper\") {\n      if (isDroppable(dragSource.id, node.parent, context)) {\n        var outerIndex = getOuterIndex(node, nodeEl, monitor);\n        if (outerIndex === null) {\n          return null;\n        }\n        return {\n          id: node.parent,\n          index: outerIndex\n        };\n      } else {\n        return {\n          id: node.id,\n          index: 0\n        };\n      }\n    }\n    var listItems = list.querySelectorAll(':scope > [role=\"listitem\"]');\n    return {\n      id: node.id,\n      index: getInnerIndex(listItems, monitor)\n    };\n  }\n};\nvar getDescendants = function (treeData, id) {\n  var descendants = [];\n  var search = function (tree, ids) {\n    var children = tree.filter(function (node) {\n      return ids.includes(node.parent);\n    });\n    if (children.length > 0) {\n      descendants = __spreadArray(__spreadArray([], descendants, true), children, true);\n      search(tree, children.map(function (node) {\n        return node.id;\n      }));\n    }\n  };\n  search(treeData, [id]);\n  return descendants;\n};\nvar getBackendOptions = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    backends: [{\n      id: \"html5\",\n      backend: HTML5Backend,\n      options: options.html5,\n      transition: PointerTransition\n    }, {\n      id: \"touch\",\n      backend: TouchBackend,\n      options: options.touch || {\n        enableMouseEvents: true\n      },\n      preview: true,\n      transition: TouchTransition\n    }]\n  };\n};\nvar TreeContext = createContext({});\nvar TreeProvider = function (props) {\n  var _a = useOpenIdsHelper(props.tree, props.initialOpen),\n    openIds = _a[0],\n    _b = _a[1],\n    handleToggle = _b.handleToggle,\n    handleCloseAll = _b.handleCloseAll,\n    handleOpenAll = _b.handleOpenAll,\n    handleOpen = _b.handleOpen,\n    handleClose = _b.handleClose;\n  useImperativeHandle(props.treeRef, function () {\n    return {\n      open: function (targetIds) {\n        return handleOpen(targetIds, props.onChangeOpen);\n      },\n      close: function (targetIds) {\n        return handleClose(targetIds, props.onChangeOpen);\n      },\n      openAll: function () {\n        return handleOpenAll(props.onChangeOpen);\n      },\n      closeAll: function () {\n        return handleCloseAll(props.onChangeOpen);\n      }\n    };\n  });\n  var canDropCallback = props.canDrop;\n  var canDragCallback = props.canDrag;\n  var value = __assign(__assign({\n    listComponent: \"ul\",\n    listItemComponent: \"li\",\n    placeholderComponent: \"li\",\n    sort: true,\n    insertDroppableFirst: true,\n    dropTargetOffset: 0,\n    initialOpen: false\n  }, props), {\n    openIds: openIds,\n    onDrop: function (id, parentId, index) {\n      var options = {\n        dragSourceId: id,\n        dropTargetId: parentId,\n        dragSource: getTreeItem(props.tree, id),\n        dropTarget: getTreeItem(props.tree, parentId)\n      };\n      if (props.sort === false) {\n        var _a = getModifiedIndex(props.tree, id, parentId, index),\n          destIndex = _a[1];\n        options.destinationIndex = destIndex;\n        props.onDrop(mutateTreeWithIndex(props.tree, id, parentId, index), options);\n        return;\n      }\n      props.onDrop(mutateTree(props.tree, id, parentId), options);\n    },\n    canDrop: canDropCallback ? function (id, parentId) {\n      return canDropCallback(props.tree, {\n        dragSourceId: id,\n        dropTargetId: parentId,\n        dragSource: getTreeItem(props.tree, id),\n        dropTarget: getTreeItem(props.tree, parentId)\n      });\n    } : undefined,\n    canDrag: canDragCallback ? function (id) {\n      return canDragCallback(getTreeItem(props.tree, id));\n    } : undefined,\n    onToggle: function (id) {\n      return handleToggle(id, props.onChangeOpen);\n    }\n  });\n  return React.createElement(TreeContext.Provider, {\n    value: value\n  }, props.children);\n};\nvar DragControlContext = createContext({});\nvar initialState$1 = {\n  isLock: false\n};\nvar DragControlProvider = function (props) {\n  var _a = useState(initialState$1.isLock),\n    isLock = _a[0],\n    setIsLock = _a[1];\n  return React.createElement(DragControlContext.Provider, {\n    value: {\n      isLock: isLock,\n      lock: function () {\n        return setIsLock(true);\n      },\n      unlock: function () {\n        return setIsLock(false);\n      }\n    }\n  }, props.children);\n};\nvar PlaceholderContext = createContext({});\nvar initialState = {\n  dropTargetId: undefined,\n  index: undefined\n};\nvar PlaceholderProvider = function (props) {\n  var _a = useState(initialState.dropTargetId),\n    dropTargetId = _a[0],\n    setDropTargetId = _a[1];\n  var _b = useState(initialState.index),\n    index = _b[0],\n    setIndex = _b[1];\n  var showPlaceholder = function (dropTargetId, index) {\n    setDropTargetId(dropTargetId);\n    setIndex(index);\n  };\n  var hidePlaceholder = function () {\n    setDropTargetId(initialState.dropTargetId);\n    setIndex(initialState.index);\n  };\n  return React.createElement(PlaceholderContext.Provider, {\n    value: {\n      dropTargetId: dropTargetId,\n      index: index,\n      showPlaceholder: showPlaceholder,\n      hidePlaceholder: hidePlaceholder\n    }\n  }, props.children);\n};\nvar Providers = function (props) {\n  return React.createElement(TreeProvider, __assign({}, props), React.createElement(DragControlProvider, null, React.createElement(PlaceholderProvider, null, props.children)));\n};\n\n/**\n * This is a hook to allow text selection by mouse in the text input area in a node.\n * Temporarily disables node dragging while the pointer is over the text input area.\n */\nvar useDragControl = function (ref) {\n  var dragControlContext = useContext(DragControlContext);\n  useEffect(function () {\n    if (!ref.current) return;\n    var node = ref.current;\n    var lock = function (e) {\n      var target = e.target;\n      if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n        dragControlContext.lock();\n      }\n    };\n    var unlock = function (e) {\n      var target = e.target;\n      if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n        dragControlContext.unlock();\n      }\n    };\n    var handleMouseOver = function (e) {\n      return lock(e);\n    };\n    var handleMouseOut = function (e) {\n      return unlock(e);\n    };\n    var handleFocusIn = function (e) {\n      return lock(e);\n    };\n    var handleFocusOut = function (e) {\n      return unlock(e);\n    };\n    // In Firefox or Safari,\n    // the focusout event is not fired when the focused element is unmounted.\n    // Therefore, it detects the unmounting of a child element\n    // and unlocks tree if the focus is on the body element after unmounting.\n    var observer = new MutationObserver(function () {\n      if (document.activeElement === document.body) {\n        dragControlContext.unlock();\n      }\n    });\n    observer.observe(node, {\n      subtree: true,\n      childList: true\n    });\n    node.addEventListener(\"mouseover\", handleMouseOver);\n    node.addEventListener(\"mouseout\", handleMouseOut);\n    node.addEventListener(\"focusin\", handleFocusIn);\n    node.addEventListener(\"focusout\", handleFocusOut);\n    return function () {\n      observer.disconnect();\n      node.removeEventListener(\"mouseover\", handleMouseOver);\n      node.removeEventListener(\"mouseout\", handleMouseOut);\n      node.removeEventListener(\"focusin\", handleFocusIn);\n      node.removeEventListener(\"focusout\", handleFocusOut);\n    };\n  }, [ref, dragControlContext]);\n  useEffect(function () {\n    var _a;\n    (_a = ref.current) === null || _a === void 0 ? void 0 : _a.setAttribute(\"draggable\", dragControlContext.isLock ? \"false\" : \"true\");\n  }, [ref, dragControlContext.isLock]);\n};\nvar ItemTypes = {\n  TREE_ITEM: Symbol()\n};\nvar dragSourceElement = null;\nvar register = function (e) {\n  var target = e.target;\n  if (target instanceof HTMLElement) {\n    var source = target.closest('[role=\"listitem\"]');\n    if (e.currentTarget === source) {\n      dragSourceElement = source;\n    }\n  }\n};\nvar handleDragStart = function (e) {\n  return register(e);\n};\nvar handleTouchStart = function (e) {\n  return register(e);\n};\nvar useDragNode = function (item, ref) {\n  var treeContext = useTreeContext();\n  useEffect(function () {\n    var node = ref.current;\n    node === null || node === void 0 ? void 0 : node.addEventListener(\"dragstart\", handleDragStart);\n    node === null || node === void 0 ? void 0 : node.addEventListener(\"touchstart\", handleTouchStart, {\n      passive: true\n    });\n    return function () {\n      node === null || node === void 0 ? void 0 : node.removeEventListener(\"dragstart\", handleDragStart);\n      node === null || node === void 0 ? void 0 : node.removeEventListener(\"touchstart\", handleTouchStart);\n    };\n  }, [ref]);\n  var _a = useDrag({\n      type: ItemTypes.TREE_ITEM,\n      item: function () {\n        return __assign({\n          ref: ref\n        }, item);\n      },\n      canDrag: function () {\n        var canDrag = treeContext.canDrag;\n        if (dragSourceElement !== ref.current) {\n          return false;\n        }\n        if (canDrag) {\n          return canDrag(item.id);\n        }\n        return true;\n      },\n      collect: function (monitor) {\n        return {\n          isDragging: monitor.isDragging()\n        };\n      }\n    }),\n    isDragging = _a[0].isDragging,\n    drag = _a[1],\n    preview = _a[2];\n  return [isDragging, drag, preview];\n};\nvar useDragOver = function (id, isOpen, dragOverHandler) {\n  var stack = useRef(0);\n  var timer = useRef(0);\n  var onDragEnter = function () {\n    stack.current += 1;\n    if (stack.current === 1 && !isOpen) {\n      timer.current = window.setTimeout(function () {\n        return dragOverHandler(id);\n      }, 500);\n    }\n  };\n  var onDragLeave = function () {\n    stack.current -= 1;\n    if (stack.current === 0) {\n      window.clearTimeout(timer.current);\n    }\n  };\n  var onDrop = function () {\n    if (timer.current > 0) {\n      window.clearTimeout(timer.current);\n    }\n    stack.current = 0;\n    timer.current = 0;\n  };\n  return {\n    onDragEnter: onDragEnter,\n    onDragLeave: onDragLeave,\n    onDrop: onDrop\n  };\n};\nvar useDropRoot = function (ref) {\n  var treeContext = useTreeContext();\n  var placeholderContext = useContext(PlaceholderContext);\n  var _a = useDrop({\n      accept: ItemTypes.TREE_ITEM,\n      drop: function (item, monitor) {\n        var rootId = treeContext.rootId,\n          onDrop = treeContext.onDrop;\n        var dropTargetId = placeholderContext.dropTargetId,\n          index = placeholderContext.index;\n        if (monitor.isOver({\n          shallow: true\n        }) && dropTargetId !== undefined && index !== undefined) {\n          onDrop(item.id, rootId, index);\n        }\n        placeholderContext.hidePlaceholder();\n      },\n      canDrop: function (item, monitor) {\n        var rootId = treeContext.rootId;\n        if (monitor.isOver({\n          shallow: true\n        })) {\n          if (item === undefined) {\n            return false;\n          }\n          return isDroppable(item.id, rootId, treeContext);\n        }\n        return false;\n      },\n      hover: function (dragItem, monitor) {\n        if (monitor.isOver({\n          shallow: true\n        })) {\n          var rootId = treeContext.rootId;\n          var dropTargetId = placeholderContext.dropTargetId,\n            index = placeholderContext.index,\n            showPlaceholder = placeholderContext.showPlaceholder,\n            hidePlaceholder = placeholderContext.hidePlaceholder;\n          var dropTarget = getDropTarget(null, ref.current, monitor, treeContext);\n          if (dropTarget === null || !isDroppable(dragItem.id, rootId, treeContext)) {\n            hidePlaceholder();\n            return;\n          }\n          if (dropTarget.id !== dropTargetId || dropTarget.index !== index) {\n            showPlaceholder(dropTarget.id, dropTarget.index);\n          }\n        }\n      },\n      collect: function (monitor) {\n        var dragSource = monitor.getItem();\n        return {\n          isOver: monitor.isOver({\n            shallow: true\n          }) && monitor.canDrop(),\n          dragSource: dragSource\n        };\n      }\n    }),\n    _b = _a[0],\n    isOver = _b.isOver,\n    dragSource = _b.dragSource,\n    drop = _a[1];\n  return [isOver, dragSource, drop];\n};\nvar useDropNode = function (item, ref) {\n  var treeContext = useTreeContext();\n  var placeholderContext = useContext(PlaceholderContext);\n  var _a = useDrop({\n      accept: ItemTypes.TREE_ITEM,\n      drop: function (dragSource, monitor) {\n        var dropTargetId = placeholderContext.dropTargetId,\n          index = placeholderContext.index;\n        if (monitor.isOver({\n          shallow: true\n        }) && dropTargetId !== undefined && index !== undefined) {\n          treeContext.onDrop(dragSource.id, dropTargetId, index);\n        }\n        placeholderContext.hidePlaceholder();\n      },\n      canDrop: function (dragSource, monitor) {\n        if (monitor.isOver({\n          shallow: true\n        })) {\n          var dropTarget = getDropTarget(item, ref.current, monitor, treeContext);\n          if (dropTarget === null) {\n            return false;\n          }\n          return isDroppable(dragSource.id, dropTarget.id, treeContext);\n        }\n        return false;\n      },\n      hover: function (dragSource, monitor) {\n        if (monitor.isOver({\n          shallow: true\n        })) {\n          var dropTargetId = placeholderContext.dropTargetId,\n            index = placeholderContext.index,\n            showPlaceholder = placeholderContext.showPlaceholder,\n            hidePlaceholder = placeholderContext.hidePlaceholder;\n          var dropTarget = getDropTarget(item, ref.current, monitor, treeContext);\n          if (dropTarget === null || !isDroppable(dragSource.id, dropTarget.id, treeContext)) {\n            hidePlaceholder();\n            return;\n          }\n          if (dropTarget.id !== dropTargetId || dropTarget.index !== index) {\n            showPlaceholder(dropTarget.id, dropTarget.index);\n          }\n        }\n      },\n      collect: function (monitor) {\n        var dragSource = monitor.getItem();\n        return {\n          isOver: monitor.isOver({\n            shallow: true\n          }) && monitor.canDrop(),\n          dragSource: dragSource\n        };\n      }\n    }),\n    _b = _a[0],\n    isOver = _b.isOver,\n    dragSource = _b.dragSource,\n    drop = _a[1];\n  return [isOver, dragSource, drop];\n};\nvar useOpenIdsHelper = function (tree, initialOpen) {\n  var initialOpenIds = [];\n  if (initialOpen === true) {\n    initialOpenIds = tree.filter(function (node) {\n      return node.droppable;\n    }).map(function (node) {\n      return node.id;\n    });\n  } else if (Array.isArray(initialOpen)) {\n    initialOpenIds = initialOpen;\n  }\n  var _a = useState(initialOpenIds),\n    openIds = _a[0],\n    setOpenIds = _a[1];\n  var handleToggle = function (targetId, callback) {\n    var newOpenIds = openIds.includes(targetId) ? openIds.filter(function (id) {\n      return id !== targetId;\n    }) : __spreadArray(__spreadArray([], openIds, true), [targetId], false);\n    setOpenIds(newOpenIds);\n    if (callback) {\n      callback(newOpenIds);\n    }\n  };\n  var handleCloseAll = function (callback) {\n    setOpenIds([]);\n    if (callback) {\n      callback([]);\n    }\n  };\n  var handleOpenAll = function (callback) {\n    var newOpenIds = tree.filter(function (node) {\n      return node.droppable;\n    }).map(function (node) {\n      return node.id;\n    });\n    setOpenIds(newOpenIds);\n    if (callback) {\n      callback(newOpenIds);\n    }\n  };\n  var handleOpen = function (targetIds, callback) {\n    var newOpenIds = __spreadArray(__spreadArray([], openIds, true), tree.filter(function (node) {\n      return node.droppable && (Array.isArray(targetIds) ? targetIds.includes(node.id) : node.id === targetIds);\n    }).map(function (node) {\n      return node.id;\n    }), true).filter(function (value, index, self) {\n      return self.indexOf(value) === index;\n    });\n    setOpenIds(newOpenIds);\n    if (callback) {\n      callback(newOpenIds);\n    }\n  };\n  var handleClose = function (targetIds, callback) {\n    var newOpenIds = openIds.filter(function (id) {\n      return Array.isArray(targetIds) ? !targetIds.includes(id) : id !== targetIds;\n    });\n    setOpenIds(newOpenIds);\n    if (callback) {\n      callback(newOpenIds);\n    }\n  };\n  return [openIds, {\n    handleToggle: handleToggle,\n    handleCloseAll: handleCloseAll,\n    handleOpenAll: handleOpenAll,\n    handleOpen: handleOpen,\n    handleClose: handleClose\n  }];\n};\nvar useTreeDragLayer = function () {\n  return useDragLayer(function (monitor) {\n    var itemType = monitor.getItemType();\n    return {\n      item: monitor.getItem(),\n      clientOffset: monitor.getClientOffset(),\n      isDragging: monitor.isDragging() && itemType === ItemTypes.TREE_ITEM\n    };\n  });\n};\nvar useTreeContext = function () {\n  var treeContext = useContext(TreeContext);\n  if (!treeContext) {\n    throw new Error(\"useTreeContext must be used under TreeProvider\");\n  }\n  return treeContext;\n};\nvar useContainerClassName = function (parentId, isOver) {\n  var _a = useTreeContext(),\n    rootId = _a.rootId,\n    rootProps = _a.rootProps,\n    classes = _a.classes;\n  var className = (classes === null || classes === void 0 ? void 0 : classes.container) || \"\";\n  if (isOver && (classes === null || classes === void 0 ? void 0 : classes.dropTarget)) {\n    className = \"\".concat(className, \" \").concat(classes.dropTarget);\n  }\n  if (parentId === rootId && (classes === null || classes === void 0 ? void 0 : classes.root)) {\n    className = \"\".concat(className, \" \").concat(classes.root);\n  }\n  if (parentId === rootId && (rootProps === null || rootProps === void 0 ? void 0 : rootProps.className)) {\n    className = \"\".concat(className, \" \").concat(rootProps.className);\n  }\n  className = className.trim();\n  return className;\n};\nvar Node = function (props) {\n  var treeContext = useTreeContext();\n  var placeholderContext = useContext(PlaceholderContext);\n  var ref = useRef(null);\n  var item = treeContext.tree.find(function (node) {\n    return node.id === props.id;\n  });\n  var openIds = treeContext.openIds,\n    classes = treeContext.classes;\n  var open = openIds.includes(props.id);\n  var _a = useDragNode(item, ref),\n    isDragging = _a[0],\n    drag = _a[1],\n    preview = _a[2];\n  var _b = useDropNode(item, ref),\n    isOver = _b[0],\n    dragSource = _b[1],\n    drop = _b[2];\n  drag(ref);\n  if (isDroppable(dragSource === null || dragSource === void 0 ? void 0 : dragSource.id, props.id, treeContext)) {\n    drop(ref);\n  }\n  var hasChild = !!treeContext.tree.find(function (node) {\n    return node.parent === props.id;\n  });\n  useEffect(function () {\n    if (treeContext.dragPreviewRender) {\n      preview(getEmptyImage(), {\n        captureDraggingState: true\n      });\n    }\n  }, [preview, treeContext.dragPreviewRender]);\n  useDragControl(ref);\n  var handleToggle = function () {\n    return treeContext.onToggle(item.id);\n  };\n  var Component = treeContext.listItemComponent;\n  var className = (classes === null || classes === void 0 ? void 0 : classes.listItem) || \"\";\n  if (isOver && (classes === null || classes === void 0 ? void 0 : classes.dropTarget)) {\n    className = \"\".concat(className, \" \").concat(classes.dropTarget);\n  }\n  if (isDragging && (classes === null || classes === void 0 ? void 0 : classes.draggingSource)) {\n    className = \"\".concat(className, \" \").concat(classes.draggingSource);\n  }\n  var draggable = treeContext.canDrag ? treeContext.canDrag(props.id) : true;\n  var isDropTarget = placeholderContext.dropTargetId === props.id;\n  var params = {\n    depth: props.depth,\n    isOpen: open,\n    isDragging: isDragging,\n    isDropTarget: isDropTarget,\n    draggable: draggable,\n    hasChild: hasChild,\n    containerRef: ref,\n    onToggle: handleToggle\n  };\n  return React.createElement(Component, {\n    ref: ref,\n    className: className,\n    role: \"listitem\"\n  }, treeContext.render(item, params), open && hasChild && React.createElement(Container, {\n    parentId: props.id,\n    depth: props.depth + 1\n  }));\n};\nvar Placeholder = function (props) {\n  var _a = useTreeContext(),\n    placeholderRender = _a.placeholderRender,\n    Component = _a.placeholderComponent,\n    classes = _a.classes;\n  var placeholderContext = useContext(PlaceholderContext);\n  var manager = useDragDropManager();\n  var monitor = manager.getMonitor();\n  var dragSource = monitor.getItem();\n  if (!placeholderRender || !dragSource) {\n    return null;\n  }\n  var visible = props.dropTargetId === placeholderContext.dropTargetId && (props.index === placeholderContext.index || props.index === undefined && props.listCount === placeholderContext.index);\n  if (!visible) {\n    return null;\n  }\n  return React.createElement(Component, {\n    className: (classes === null || classes === void 0 ? void 0 : classes.placeholder) || \"\"\n  }, placeholderRender(dragSource, {\n    depth: props.depth\n  }));\n};\nvar Container = function (props) {\n  var treeContext = useTreeContext();\n  var ref = useRef(null);\n  var nodes = treeContext.tree.filter(function (l) {\n    return l.parent === props.parentId;\n  });\n  var view = nodes;\n  var sortCallback = typeof treeContext.sort === \"function\" ? treeContext.sort : compareItems;\n  if (treeContext.insertDroppableFirst) {\n    var droppableNodes = nodes.filter(function (n) {\n      return n.droppable;\n    });\n    var nonDroppableNodes = nodes.filter(function (n) {\n      return !n.droppable;\n    });\n    if (treeContext.sort === false) {\n      view = __spreadArray(__spreadArray([], droppableNodes, true), nonDroppableNodes, true);\n    } else {\n      droppableNodes = droppableNodes.sort(sortCallback);\n      nonDroppableNodes = nonDroppableNodes.sort(sortCallback);\n      view = __spreadArray(__spreadArray([], droppableNodes, true), nonDroppableNodes, true);\n    }\n  } else {\n    if (treeContext.sort !== false) {\n      view = nodes.sort(sortCallback);\n    }\n  }\n  var _a = useDropRoot(ref),\n    isOver = _a[0],\n    dragSource = _a[1],\n    drop = _a[2];\n  if (props.parentId === treeContext.rootId && isDroppable(dragSource === null || dragSource === void 0 ? void 0 : dragSource.id, treeContext.rootId, treeContext)) {\n    drop(ref);\n  }\n  var className = useContainerClassName(props.parentId, isOver);\n  var rootProps = treeContext.rootProps || {};\n  var Component = treeContext.listComponent;\n  return React.createElement(Component, __assign({\n    ref: ref,\n    role: \"list\"\n  }, rootProps, {\n    className: className\n  }), view.map(function (node, index) {\n    return React.createElement(React.Fragment, {\n      key: node.id\n    }, React.createElement(Placeholder, {\n      depth: props.depth,\n      listCount: view.length,\n      dropTargetId: props.parentId,\n      index: index\n    }), React.createElement(Node, {\n      id: node.id,\n      depth: props.depth\n    }));\n  }), React.createElement(Placeholder, {\n    depth: props.depth,\n    listCount: view.length,\n    dropTargetId: props.parentId\n  }));\n};\nvar rootStyle = {\n  height: \"100%\",\n  left: 0,\n  pointerEvents: \"none\",\n  position: \"fixed\",\n  top: 0,\n  width: \"100%\",\n  zIndex: 100\n};\nvar getItemStyles = function (monitorProps) {\n  var offset = monitorProps.clientOffset;\n  if (!offset) {\n    return {};\n  }\n  var x = offset.x,\n    y = offset.y;\n  var transform = \"translate(\".concat(x, \"px, \").concat(y, \"px)\");\n  return {\n    pointerEvents: \"none\",\n    transform: transform\n  };\n};\nvar DragLayer = function () {\n  var context = useTreeContext();\n  var monitorProps = useTreeDragLayer();\n  var isDragging = monitorProps.isDragging,\n    clientOffset = monitorProps.clientOffset;\n  if (!isDragging || !clientOffset) {\n    return null;\n  }\n  return React.createElement(\"div\", {\n    style: rootStyle\n  }, React.createElement(\"div\", {\n    style: getItemStyles(monitorProps)\n  }, context.dragPreviewRender && context.dragPreviewRender(monitorProps)));\n};\nfunction TreeInner(props, ref) {\n  return React.createElement(Providers, __assign({}, props, {\n    treeRef: ref\n  }), props.dragPreviewRender && React.createElement(DragLayer, null), React.createElement(Container, {\n    parentId: props.rootId,\n    depth: 0\n  }));\n}\nvar Tree = forwardRef(TreeInner);\nexport { Container, DragLayer, ItemTypes, Node, Tree, compareItems, getBackendOptions, getDescendants, getDropTarget, getModifiedIndex, getTreeItem, isAncestor, isDroppable, mutateTree, mutateTreeWithIndex, useContainerClassName, useDragControl, useDragNode, useDragOver, useDropNode, useDropRoot, useOpenIdsHelper, useTreeContext, useTreeDragLayer };","map":{"version":3,"sources":[],"names":[],"mappings":"","sourcesContent":["import React, { createContext, useImperativeHandle, useState, useContext, useEffect, useRef, forwardRef } from 'react';\nimport { HTML5Backend, getEmptyImage } from 'react-dnd-html5-backend';\nimport { PointerTransition, TouchTransition } from 'dnd-multi-backend';\nexport { MultiBackend } from 'dnd-multi-backend';\nimport { TouchBackend } from 'react-dnd-touch-backend';\nimport { useDrag, useDrop, useDragLayer, useDragDropManager } from 'react-dnd';\nexport { DndProvider } from 'react-dnd';\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\n\nvar compareItems = function (a, b) {\n    if (a.text > b.text) {\n        return 1;\n    }\n    else if (a.text < b.text) {\n        return -1;\n    }\n    return 0;\n};\n\nvar getTreeItem = function (tree, id) { return tree.find(function (n) { return n.id === id; }); };\n\nvar isAncestor = function (tree, sourceId, targetId) {\n    if (targetId === 0) {\n        return false;\n    }\n    var targetNode = tree.find(function (node) { return node.id === targetId; });\n    if (targetNode === undefined) {\n        return false;\n    }\n    if (targetNode.parent === sourceId) {\n        return true;\n    }\n    return isAncestor(tree, sourceId, targetNode.parent);\n};\n\nvar isDroppable = function (dragSourceId, dropTargetId, treeContext) {\n    var tree = treeContext.tree, rootId = treeContext.rootId, canDrop = treeContext.canDrop;\n    if (dragSourceId === undefined) {\n        if (dropTargetId === rootId) {\n            return true;\n        }\n        var dropTargetNode = tree.find(function (node) { return node.id === dropTargetId; });\n        if (dropTargetNode && dropTargetNode.droppable) {\n            return true;\n        }\n        return false;\n    }\n    else {\n        if (canDrop) {\n            var result = canDrop(dragSourceId, dropTargetId);\n            if (result !== undefined) {\n                return result;\n            }\n        }\n        if (dragSourceId === dropTargetId) {\n            return false;\n        }\n        var dragSourceNode = tree.find(function (node) { return node.id === dragSourceId; });\n        if (dragSourceNode === undefined ||\n            dragSourceNode.parent === dropTargetId) {\n            return false;\n        }\n        if (dropTargetId === rootId) {\n            return true;\n        }\n        var dropTargetNode = tree.find(function (node) { return node.id === dropTargetId; });\n        if (dropTargetNode === undefined || !dropTargetNode.droppable) {\n            return false;\n        }\n        return !isAncestor(tree, dragSourceId, dropTargetId);\n    }\n};\n\nvar mutateTree = function (tree, dragSourceId, dropTargetId) {\n    return tree.map(function (node) {\n        if (node.id === dragSourceId) {\n            return __assign(__assign({}, node), { parent: dropTargetId });\n        }\n        return node;\n    });\n};\n\nvar getSrcIndex = function (tree, dragSourceId) {\n    return tree.findIndex(function (node) { return node.id === dragSourceId; });\n};\nvar getDestIndex = function (tree, dropTargetId, index) {\n    if (index === 0) {\n        return 0;\n    }\n    var siblings = tree.filter(function (node) { return node.parent === dropTargetId; });\n    if (siblings[index]) {\n        return tree.findIndex(function (node) { return node.id === siblings[index].id; });\n    }\n    return tree.findIndex(function (node) { return node.id === siblings[index - 1].id; }) + 1;\n};\nvar getModifiedIndex = function (tree, dragSourceId, dropTargetId, index) {\n    var srcIndex = getSrcIndex(tree, dragSourceId);\n    var destIndex = getDestIndex(tree, dropTargetId, index);\n    destIndex = destIndex > srcIndex ? destIndex - 1 : destIndex;\n    return [srcIndex, destIndex];\n};\n\nvar arrayMoveMutable = function (array, fromIndex, toIndex) {\n    var startIndex = fromIndex < 0 ? array.length + fromIndex : fromIndex;\n    if (startIndex >= 0 && startIndex < array.length) {\n        var endIndex = toIndex < 0 ? array.length + toIndex : toIndex;\n        var item = array.splice(fromIndex, 1)[0];\n        array.splice(endIndex, 0, item);\n    }\n};\nvar mutateTreeWithIndex = function (tree, dragSourceId, dropTargetId, index) {\n    var _a = getModifiedIndex(tree, dragSourceId, dropTargetId, index), srcIndex = _a[0], destIndex = _a[1];\n    var newTree = __spreadArray([], tree, true);\n    arrayMoveMutable(newTree, srcIndex, destIndex);\n    return newTree.map(function (node) {\n        if (node.id === dragSourceId) {\n            return __assign(__assign({}, node), { parent: dropTargetId });\n        }\n        return node;\n    });\n};\n\nvar compareYCoord = function (el, pointerY) {\n    var bbox = el.getBoundingClientRect();\n    var centerY = bbox.top + bbox.height / 2;\n    return pointerY > centerY ? \"down\" : \"up\";\n};\nvar getInnerIndex = function (listItems, monitor) {\n    var pos = \"\";\n    var index = 0;\n    listItems.forEach(function (el, key) {\n        var _a;\n        var flag = compareYCoord(el, ((_a = monitor.getClientOffset()) === null || _a === void 0 ? void 0 : _a.y) || 0);\n        if (pos === \"\") {\n            pos = flag;\n        }\n        else if (pos !== flag) {\n            pos = flag;\n            index = key;\n        }\n        if (key === listItems.length - 1 && flag === \"down\") {\n            index = key + 1;\n        }\n    });\n    return index;\n};\nvar getOuterIndex = function (node, nodeEl, monitor) {\n    var parentList = nodeEl.closest('[role=\"list\"]');\n    var parentListItems = parentList === null || parentList === void 0 ? void 0 : parentList.querySelectorAll(':scope > [role=\"listitem\"]');\n    if (!parentListItems) {\n        return null;\n    }\n    return getInnerIndex(parentListItems, monitor);\n};\nvar getHoverPosition = function (el, pointerY, context) {\n    var bbox = el.getBoundingClientRect();\n    var offsetY = context.dropTargetOffset;\n    var upSideY = bbox.top + offsetY;\n    var lowerSideY = bbox.bottom - offsetY;\n    if (pointerY > lowerSideY) {\n        return \"lower\";\n    }\n    else if (pointerY < upSideY) {\n        return \"upper\";\n    }\n    return \"middle\";\n};\nvar getDropTarget = function (node, nodeEl, monitor, context) {\n    var _a;\n    if (!nodeEl) {\n        return null;\n    }\n    if (node === null) {\n        var listItems = nodeEl.querySelectorAll(':scope > [role=\"listitem\"]');\n        return {\n            id: context.rootId,\n            index: getInnerIndex(listItems, monitor),\n        };\n    }\n    var dragSource = monitor.getItem();\n    var list = nodeEl.querySelector('[role=\"list\"]');\n    var hoverPosition = getHoverPosition(nodeEl, ((_a = monitor.getClientOffset()) === null || _a === void 0 ? void 0 : _a.y) || 0, context);\n    if (!list) {\n        if (hoverPosition === \"middle\") {\n            return {\n                id: node.id,\n                index: 0,\n            };\n        }\n        if (isDroppable(dragSource.id, node.parent, context)) {\n            var outerIndex = getOuterIndex(node, nodeEl, monitor);\n            if (outerIndex === null) {\n                return null;\n            }\n            return {\n                id: node.parent,\n                index: outerIndex,\n            };\n        }\n        return null;\n    }\n    else {\n        if (hoverPosition === \"upper\") {\n            if (isDroppable(dragSource.id, node.parent, context)) {\n                var outerIndex = getOuterIndex(node, nodeEl, monitor);\n                if (outerIndex === null) {\n                    return null;\n                }\n                return {\n                    id: node.parent,\n                    index: outerIndex,\n                };\n            }\n            else {\n                return {\n                    id: node.id,\n                    index: 0,\n                };\n            }\n        }\n        var listItems = list.querySelectorAll(':scope > [role=\"listitem\"]');\n        return {\n            id: node.id,\n            index: getInnerIndex(listItems, monitor),\n        };\n    }\n};\n\nvar getDescendants = function (treeData, id) {\n    var descendants = [];\n    var search = function (tree, ids) {\n        var children = tree.filter(function (node) { return ids.includes(node.parent); });\n        if (children.length > 0) {\n            descendants = __spreadArray(__spreadArray([], descendants, true), children, true);\n            search(tree, children.map(function (node) { return node.id; }));\n        }\n    };\n    search(treeData, [id]);\n    return descendants;\n};\n\nvar getBackendOptions = function (options) {\n    if (options === void 0) { options = {}; }\n    return {\n        backends: [\n            {\n                id: \"html5\",\n                backend: HTML5Backend,\n                options: options.html5,\n                transition: PointerTransition,\n            },\n            {\n                id: \"touch\",\n                backend: TouchBackend,\n                options: options.touch || { enableMouseEvents: true },\n                preview: true,\n                transition: TouchTransition,\n            },\n        ],\n    };\n};\n\nvar TreeContext = createContext({});\nvar TreeProvider = function (props) {\n    var _a = useOpenIdsHelper(props.tree, props.initialOpen), openIds = _a[0], _b = _a[1], handleToggle = _b.handleToggle, handleCloseAll = _b.handleCloseAll, handleOpenAll = _b.handleOpenAll, handleOpen = _b.handleOpen, handleClose = _b.handleClose;\n    useImperativeHandle(props.treeRef, function () { return ({\n        open: function (targetIds) { return handleOpen(targetIds, props.onChangeOpen); },\n        close: function (targetIds) { return handleClose(targetIds, props.onChangeOpen); },\n        openAll: function () { return handleOpenAll(props.onChangeOpen); },\n        closeAll: function () { return handleCloseAll(props.onChangeOpen); },\n    }); });\n    var canDropCallback = props.canDrop;\n    var canDragCallback = props.canDrag;\n    var value = __assign(__assign({ listComponent: \"ul\", listItemComponent: \"li\", placeholderComponent: \"li\", sort: true, insertDroppableFirst: true, dropTargetOffset: 0, initialOpen: false }, props), { openIds: openIds, onDrop: function (id, parentId, index) {\n            var options = {\n                dragSourceId: id,\n                dropTargetId: parentId,\n                dragSource: getTreeItem(props.tree, id),\n                dropTarget: getTreeItem(props.tree, parentId),\n            };\n            if (props.sort === false) {\n                var _a = getModifiedIndex(props.tree, id, parentId, index), destIndex = _a[1];\n                options.destinationIndex = destIndex;\n                props.onDrop(mutateTreeWithIndex(props.tree, id, parentId, index), options);\n                return;\n            }\n            props.onDrop(mutateTree(props.tree, id, parentId), options);\n        }, canDrop: canDropCallback\n            ? function (id, parentId) {\n                return canDropCallback(props.tree, {\n                    dragSourceId: id,\n                    dropTargetId: parentId,\n                    dragSource: getTreeItem(props.tree, id),\n                    dropTarget: getTreeItem(props.tree, parentId),\n                });\n            }\n            : undefined, canDrag: canDragCallback\n            ? function (id) { return canDragCallback(getTreeItem(props.tree, id)); }\n            : undefined, onToggle: function (id) { return handleToggle(id, props.onChangeOpen); } });\n    return (React.createElement(TreeContext.Provider, { value: value }, props.children));\n};\n\nvar DragControlContext = createContext({});\nvar initialState$1 = {\n    isLock: false,\n};\nvar DragControlProvider = function (props) {\n    var _a = useState(initialState$1.isLock), isLock = _a[0], setIsLock = _a[1];\n    return (React.createElement(DragControlContext.Provider, { value: {\n            isLock: isLock,\n            lock: function () { return setIsLock(true); },\n            unlock: function () { return setIsLock(false); },\n        } }, props.children));\n};\n\nvar PlaceholderContext = createContext({});\nvar initialState = {\n    dropTargetId: undefined,\n    index: undefined,\n};\nvar PlaceholderProvider = function (props) {\n    var _a = useState(initialState.dropTargetId), dropTargetId = _a[0], setDropTargetId = _a[1];\n    var _b = useState(initialState.index), index = _b[0], setIndex = _b[1];\n    var showPlaceholder = function (dropTargetId, index) {\n        setDropTargetId(dropTargetId);\n        setIndex(index);\n    };\n    var hidePlaceholder = function () {\n        setDropTargetId(initialState.dropTargetId);\n        setIndex(initialState.index);\n    };\n    return (React.createElement(PlaceholderContext.Provider, { value: {\n            dropTargetId: dropTargetId,\n            index: index,\n            showPlaceholder: showPlaceholder,\n            hidePlaceholder: hidePlaceholder,\n        } }, props.children));\n};\n\nvar Providers = function (props) { return (React.createElement(TreeProvider, __assign({}, props),\n    React.createElement(DragControlProvider, null,\n        React.createElement(PlaceholderProvider, null, props.children)))); };\n\n/**\n * This is a hook to allow text selection by mouse in the text input area in a node.\n * Temporarily disables node dragging while the pointer is over the text input area.\n */\nvar useDragControl = function (ref) {\n    var dragControlContext = useContext(DragControlContext);\n    useEffect(function () {\n        if (!ref.current)\n            return;\n        var node = ref.current;\n        var lock = function (e) {\n            var target = e.target;\n            if (target instanceof HTMLInputElement ||\n                target instanceof HTMLTextAreaElement) {\n                dragControlContext.lock();\n            }\n        };\n        var unlock = function (e) {\n            var target = e.target;\n            if (target instanceof HTMLInputElement ||\n                target instanceof HTMLTextAreaElement) {\n                dragControlContext.unlock();\n            }\n        };\n        var handleMouseOver = function (e) { return lock(e); };\n        var handleMouseOut = function (e) { return unlock(e); };\n        var handleFocusIn = function (e) { return lock(e); };\n        var handleFocusOut = function (e) { return unlock(e); };\n        // In Firefox or Safari,\n        // the focusout event is not fired when the focused element is unmounted.\n        // Therefore, it detects the unmounting of a child element\n        // and unlocks tree if the focus is on the body element after unmounting.\n        var observer = new MutationObserver(function () {\n            if (document.activeElement === document.body) {\n                dragControlContext.unlock();\n            }\n        });\n        observer.observe(node, {\n            subtree: true,\n            childList: true,\n        });\n        node.addEventListener(\"mouseover\", handleMouseOver);\n        node.addEventListener(\"mouseout\", handleMouseOut);\n        node.addEventListener(\"focusin\", handleFocusIn);\n        node.addEventListener(\"focusout\", handleFocusOut);\n        return function () {\n            observer.disconnect();\n            node.removeEventListener(\"mouseover\", handleMouseOver);\n            node.removeEventListener(\"mouseout\", handleMouseOut);\n            node.removeEventListener(\"focusin\", handleFocusIn);\n            node.removeEventListener(\"focusout\", handleFocusOut);\n        };\n    }, [ref, dragControlContext]);\n    useEffect(function () {\n        var _a;\n        (_a = ref.current) === null || _a === void 0 ? void 0 : _a.setAttribute(\"draggable\", dragControlContext.isLock ? \"false\" : \"true\");\n    }, [ref, dragControlContext.isLock]);\n};\n\nvar ItemTypes = {\n    TREE_ITEM: Symbol(),\n};\n\nvar dragSourceElement = null;\nvar register = function (e) {\n    var target = e.target;\n    if (target instanceof HTMLElement) {\n        var source = target.closest('[role=\"listitem\"]');\n        if (e.currentTarget === source) {\n            dragSourceElement = source;\n        }\n    }\n};\nvar handleDragStart = function (e) { return register(e); };\nvar handleTouchStart = function (e) { return register(e); };\nvar useDragNode = function (item, ref) {\n    var treeContext = useTreeContext();\n    useEffect(function () {\n        var node = ref.current;\n        node === null || node === void 0 ? void 0 : node.addEventListener(\"dragstart\", handleDragStart);\n        node === null || node === void 0 ? void 0 : node.addEventListener(\"touchstart\", handleTouchStart, {\n            passive: true,\n        });\n        return function () {\n            node === null || node === void 0 ? void 0 : node.removeEventListener(\"dragstart\", handleDragStart);\n            node === null || node === void 0 ? void 0 : node.removeEventListener(\"touchstart\", handleTouchStart);\n        };\n    }, [ref]);\n    var _a = useDrag({\n        type: ItemTypes.TREE_ITEM,\n        item: function () { return (__assign({ ref: ref }, item)); },\n        canDrag: function () {\n            var canDrag = treeContext.canDrag;\n            if (dragSourceElement !== ref.current) {\n                return false;\n            }\n            if (canDrag) {\n                return canDrag(item.id);\n            }\n            return true;\n        },\n        collect: function (monitor) { return ({\n            isDragging: monitor.isDragging(),\n        }); },\n    }), isDragging = _a[0].isDragging, drag = _a[1], preview = _a[2];\n    return [isDragging, drag, preview];\n};\n\nvar useDragOver = function (id, isOpen, dragOverHandler) {\n    var stack = useRef(0);\n    var timer = useRef(0);\n    var onDragEnter = function () {\n        stack.current += 1;\n        if (stack.current === 1 && !isOpen) {\n            timer.current = window.setTimeout(function () { return dragOverHandler(id); }, 500);\n        }\n    };\n    var onDragLeave = function () {\n        stack.current -= 1;\n        if (stack.current === 0) {\n            window.clearTimeout(timer.current);\n        }\n    };\n    var onDrop = function () {\n        if (timer.current > 0) {\n            window.clearTimeout(timer.current);\n        }\n        stack.current = 0;\n        timer.current = 0;\n    };\n    return {\n        onDragEnter: onDragEnter,\n        onDragLeave: onDragLeave,\n        onDrop: onDrop,\n    };\n};\n\nvar useDropRoot = function (ref) {\n    var treeContext = useTreeContext();\n    var placeholderContext = useContext(PlaceholderContext);\n    var _a = useDrop({\n        accept: ItemTypes.TREE_ITEM,\n        drop: function (item, monitor) {\n            var rootId = treeContext.rootId, onDrop = treeContext.onDrop;\n            var dropTargetId = placeholderContext.dropTargetId, index = placeholderContext.index;\n            if (monitor.isOver({ shallow: true }) &&\n                dropTargetId !== undefined &&\n                index !== undefined) {\n                onDrop(item.id, rootId, index);\n            }\n            placeholderContext.hidePlaceholder();\n        },\n        canDrop: function (item, monitor) {\n            var rootId = treeContext.rootId;\n            if (monitor.isOver({ shallow: true })) {\n                if (item === undefined) {\n                    return false;\n                }\n                return isDroppable(item.id, rootId, treeContext);\n            }\n            return false;\n        },\n        hover: function (dragItem, monitor) {\n            if (monitor.isOver({ shallow: true })) {\n                var rootId = treeContext.rootId;\n                var dropTargetId = placeholderContext.dropTargetId, index = placeholderContext.index, showPlaceholder = placeholderContext.showPlaceholder, hidePlaceholder = placeholderContext.hidePlaceholder;\n                var dropTarget = getDropTarget(null, ref.current, monitor, treeContext);\n                if (dropTarget === null ||\n                    !isDroppable(dragItem.id, rootId, treeContext)) {\n                    hidePlaceholder();\n                    return;\n                }\n                if (dropTarget.id !== dropTargetId || dropTarget.index !== index) {\n                    showPlaceholder(dropTarget.id, dropTarget.index);\n                }\n            }\n        },\n        collect: function (monitor) {\n            var dragSource = monitor.getItem();\n            return {\n                isOver: monitor.isOver({ shallow: true }) && monitor.canDrop(),\n                dragSource: dragSource,\n            };\n        },\n    }), _b = _a[0], isOver = _b.isOver, dragSource = _b.dragSource, drop = _a[1];\n    return [isOver, dragSource, drop];\n};\n\nvar useDropNode = function (item, ref) {\n    var treeContext = useTreeContext();\n    var placeholderContext = useContext(PlaceholderContext);\n    var _a = useDrop({\n        accept: ItemTypes.TREE_ITEM,\n        drop: function (dragSource, monitor) {\n            var dropTargetId = placeholderContext.dropTargetId, index = placeholderContext.index;\n            if (monitor.isOver({ shallow: true }) &&\n                dropTargetId !== undefined &&\n                index !== undefined) {\n                treeContext.onDrop(dragSource.id, dropTargetId, index);\n            }\n            placeholderContext.hidePlaceholder();\n        },\n        canDrop: function (dragSource, monitor) {\n            if (monitor.isOver({ shallow: true })) {\n                var dropTarget = getDropTarget(item, ref.current, monitor, treeContext);\n                if (dropTarget === null) {\n                    return false;\n                }\n                return isDroppable(dragSource.id, dropTarget.id, treeContext);\n            }\n            return false;\n        },\n        hover: function (dragSource, monitor) {\n            if (monitor.isOver({ shallow: true })) {\n                var dropTargetId = placeholderContext.dropTargetId, index = placeholderContext.index, showPlaceholder = placeholderContext.showPlaceholder, hidePlaceholder = placeholderContext.hidePlaceholder;\n                var dropTarget = getDropTarget(item, ref.current, monitor, treeContext);\n                if (dropTarget === null ||\n                    !isDroppable(dragSource.id, dropTarget.id, treeContext)) {\n                    hidePlaceholder();\n                    return;\n                }\n                if (dropTarget.id !== dropTargetId || dropTarget.index !== index) {\n                    showPlaceholder(dropTarget.id, dropTarget.index);\n                }\n            }\n        },\n        collect: function (monitor) {\n            var dragSource = monitor.getItem();\n            return {\n                isOver: monitor.isOver({ shallow: true }) && monitor.canDrop(),\n                dragSource: dragSource,\n            };\n        },\n    }), _b = _a[0], isOver = _b.isOver, dragSource = _b.dragSource, drop = _a[1];\n    return [isOver, dragSource, drop];\n};\n\nvar useOpenIdsHelper = function (tree, initialOpen) {\n    var initialOpenIds = [];\n    if (initialOpen === true) {\n        initialOpenIds = tree\n            .filter(function (node) { return node.droppable; })\n            .map(function (node) { return node.id; });\n    }\n    else if (Array.isArray(initialOpen)) {\n        initialOpenIds = initialOpen;\n    }\n    var _a = useState(initialOpenIds), openIds = _a[0], setOpenIds = _a[1];\n    var handleToggle = function (targetId, callback) {\n        var newOpenIds = openIds.includes(targetId)\n            ? openIds.filter(function (id) { return id !== targetId; })\n            : __spreadArray(__spreadArray([], openIds, true), [targetId], false);\n        setOpenIds(newOpenIds);\n        if (callback) {\n            callback(newOpenIds);\n        }\n    };\n    var handleCloseAll = function (callback) {\n        setOpenIds([]);\n        if (callback) {\n            callback([]);\n        }\n    };\n    var handleOpenAll = function (callback) {\n        var newOpenIds = tree\n            .filter(function (node) { return node.droppable; })\n            .map(function (node) { return node.id; });\n        setOpenIds(newOpenIds);\n        if (callback) {\n            callback(newOpenIds);\n        }\n    };\n    var handleOpen = function (targetIds, callback) {\n        var newOpenIds = __spreadArray(__spreadArray([], openIds, true), tree\n            .filter(function (node) {\n            return node.droppable &&\n                (Array.isArray(targetIds)\n                    ? targetIds.includes(node.id)\n                    : node.id === targetIds);\n        })\n            .map(function (node) { return node.id; }), true).filter(function (value, index, self) { return self.indexOf(value) === index; });\n        setOpenIds(newOpenIds);\n        if (callback) {\n            callback(newOpenIds);\n        }\n    };\n    var handleClose = function (targetIds, callback) {\n        var newOpenIds = openIds.filter(function (id) {\n            return Array.isArray(targetIds) ? !targetIds.includes(id) : id !== targetIds;\n        });\n        setOpenIds(newOpenIds);\n        if (callback) {\n            callback(newOpenIds);\n        }\n    };\n    return [\n        openIds,\n        { handleToggle: handleToggle, handleCloseAll: handleCloseAll, handleOpenAll: handleOpenAll, handleOpen: handleOpen, handleClose: handleClose },\n    ];\n};\n\nvar useTreeDragLayer = function () {\n    return useDragLayer(function (monitor) {\n        var itemType = monitor.getItemType();\n        return {\n            item: monitor.getItem(),\n            clientOffset: monitor.getClientOffset(),\n            isDragging: monitor.isDragging() && itemType === ItemTypes.TREE_ITEM,\n        };\n    });\n};\n\nvar useTreeContext = function () {\n    var treeContext = useContext(TreeContext);\n    if (!treeContext) {\n        throw new Error(\"useTreeContext must be used under TreeProvider\");\n    }\n    return treeContext;\n};\n\nvar useContainerClassName = function (parentId, isOver) {\n    var _a = useTreeContext(), rootId = _a.rootId, rootProps = _a.rootProps, classes = _a.classes;\n    var className = (classes === null || classes === void 0 ? void 0 : classes.container) || \"\";\n    if (isOver && (classes === null || classes === void 0 ? void 0 : classes.dropTarget)) {\n        className = \"\".concat(className, \" \").concat(classes.dropTarget);\n    }\n    if (parentId === rootId && (classes === null || classes === void 0 ? void 0 : classes.root)) {\n        className = \"\".concat(className, \" \").concat(classes.root);\n    }\n    if (parentId === rootId && (rootProps === null || rootProps === void 0 ? void 0 : rootProps.className)) {\n        className = \"\".concat(className, \" \").concat(rootProps.className);\n    }\n    className = className.trim();\n    return className;\n};\n\nvar Node = function (props) {\n    var treeContext = useTreeContext();\n    var placeholderContext = useContext(PlaceholderContext);\n    var ref = useRef(null);\n    var item = treeContext.tree.find(function (node) { return node.id === props.id; });\n    var openIds = treeContext.openIds, classes = treeContext.classes;\n    var open = openIds.includes(props.id);\n    var _a = useDragNode(item, ref), isDragging = _a[0], drag = _a[1], preview = _a[2];\n    var _b = useDropNode(item, ref), isOver = _b[0], dragSource = _b[1], drop = _b[2];\n    drag(ref);\n    if (isDroppable(dragSource === null || dragSource === void 0 ? void 0 : dragSource.id, props.id, treeContext)) {\n        drop(ref);\n    }\n    var hasChild = !!treeContext.tree.find(function (node) { return node.parent === props.id; });\n    useEffect(function () {\n        if (treeContext.dragPreviewRender) {\n            preview(getEmptyImage(), { captureDraggingState: true });\n        }\n    }, [preview, treeContext.dragPreviewRender]);\n    useDragControl(ref);\n    var handleToggle = function () { return treeContext.onToggle(item.id); };\n    var Component = treeContext.listItemComponent;\n    var className = (classes === null || classes === void 0 ? void 0 : classes.listItem) || \"\";\n    if (isOver && (classes === null || classes === void 0 ? void 0 : classes.dropTarget)) {\n        className = \"\".concat(className, \" \").concat(classes.dropTarget);\n    }\n    if (isDragging && (classes === null || classes === void 0 ? void 0 : classes.draggingSource)) {\n        className = \"\".concat(className, \" \").concat(classes.draggingSource);\n    }\n    var draggable = treeContext.canDrag ? treeContext.canDrag(props.id) : true;\n    var isDropTarget = placeholderContext.dropTargetId === props.id;\n    var params = {\n        depth: props.depth,\n        isOpen: open,\n        isDragging: isDragging,\n        isDropTarget: isDropTarget,\n        draggable: draggable,\n        hasChild: hasChild,\n        containerRef: ref,\n        onToggle: handleToggle,\n    };\n    return (React.createElement(Component, { ref: ref, className: className, role: \"listitem\" },\n        treeContext.render(item, params),\n        open && hasChild && (React.createElement(Container, { parentId: props.id, depth: props.depth + 1 }))));\n};\n\nvar Placeholder = function (props) {\n    var _a = useTreeContext(), placeholderRender = _a.placeholderRender, Component = _a.placeholderComponent, classes = _a.classes;\n    var placeholderContext = useContext(PlaceholderContext);\n    var manager = useDragDropManager();\n    var monitor = manager.getMonitor();\n    var dragSource = monitor.getItem();\n    if (!placeholderRender || !dragSource) {\n        return null;\n    }\n    var visible = props.dropTargetId === placeholderContext.dropTargetId &&\n        (props.index === placeholderContext.index ||\n            (props.index === undefined &&\n                props.listCount === placeholderContext.index));\n    if (!visible) {\n        return null;\n    }\n    return (React.createElement(Component, { className: (classes === null || classes === void 0 ? void 0 : classes.placeholder) || \"\" }, placeholderRender(dragSource, { depth: props.depth })));\n};\n\nvar Container = function (props) {\n    var treeContext = useTreeContext();\n    var ref = useRef(null);\n    var nodes = treeContext.tree.filter(function (l) { return l.parent === props.parentId; });\n    var view = nodes;\n    var sortCallback = typeof treeContext.sort === \"function\" ? treeContext.sort : compareItems;\n    if (treeContext.insertDroppableFirst) {\n        var droppableNodes = nodes.filter(function (n) { return n.droppable; });\n        var nonDroppableNodes = nodes.filter(function (n) { return !n.droppable; });\n        if (treeContext.sort === false) {\n            view = __spreadArray(__spreadArray([], droppableNodes, true), nonDroppableNodes, true);\n        }\n        else {\n            droppableNodes = droppableNodes.sort(sortCallback);\n            nonDroppableNodes = nonDroppableNodes.sort(sortCallback);\n            view = __spreadArray(__spreadArray([], droppableNodes, true), nonDroppableNodes, true);\n        }\n    }\n    else {\n        if (treeContext.sort !== false) {\n            view = nodes.sort(sortCallback);\n        }\n    }\n    var _a = useDropRoot(ref), isOver = _a[0], dragSource = _a[1], drop = _a[2];\n    if (props.parentId === treeContext.rootId &&\n        isDroppable(dragSource === null || dragSource === void 0 ? void 0 : dragSource.id, treeContext.rootId, treeContext)) {\n        drop(ref);\n    }\n    var className = useContainerClassName(props.parentId, isOver);\n    var rootProps = treeContext.rootProps || {};\n    var Component = treeContext.listComponent;\n    return (React.createElement(Component, __assign({ ref: ref, role: \"list\" }, rootProps, { className: className }),\n        view.map(function (node, index) { return (React.createElement(React.Fragment, { key: node.id },\n            React.createElement(Placeholder, { depth: props.depth, listCount: view.length, dropTargetId: props.parentId, index: index }),\n            React.createElement(Node, { id: node.id, depth: props.depth }))); }),\n        React.createElement(Placeholder, { depth: props.depth, listCount: view.length, dropTargetId: props.parentId })));\n};\n\nvar rootStyle = {\n    height: \"100%\",\n    left: 0,\n    pointerEvents: \"none\",\n    position: \"fixed\",\n    top: 0,\n    width: \"100%\",\n    zIndex: 100,\n};\nvar getItemStyles = function (monitorProps) {\n    var offset = monitorProps.clientOffset;\n    if (!offset) {\n        return {};\n    }\n    var x = offset.x, y = offset.y;\n    var transform = \"translate(\".concat(x, \"px, \").concat(y, \"px)\");\n    return {\n        pointerEvents: \"none\",\n        transform: transform,\n    };\n};\nvar DragLayer = function () {\n    var context = useTreeContext();\n    var monitorProps = useTreeDragLayer();\n    var isDragging = monitorProps.isDragging, clientOffset = monitorProps.clientOffset;\n    if (!isDragging || !clientOffset) {\n        return null;\n    }\n    return (React.createElement(\"div\", { style: rootStyle },\n        React.createElement(\"div\", { style: getItemStyles(monitorProps) }, context.dragPreviewRender && context.dragPreviewRender(monitorProps))));\n};\n\nfunction TreeInner(props, ref) {\n    return (React.createElement(Providers, __assign({}, props, { treeRef: ref }),\n        props.dragPreviewRender && React.createElement(DragLayer, null),\n        React.createElement(Container, { parentId: props.rootId, depth: 0 })));\n}\nvar Tree = forwardRef(TreeInner);\n\nexport { Container, DragLayer, ItemTypes, Node, Tree, compareItems, getBackendOptions, getDescendants, getDropTarget, getModifiedIndex, getTreeItem, isAncestor, isDroppable, mutateTree, mutateTreeWithIndex, useContainerClassName, useDragControl, useDragNode, useDragOver, useDropNode, useDropRoot, useOpenIdsHelper, useTreeContext, useTreeDragLayer };\n//# sourceMappingURL=index.esm.js.map\n"]},"metadata":{},"sourceType":"module"}